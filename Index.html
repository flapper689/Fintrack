<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FinTrack - AI Categorizer</title>
    <!-- Favicon: Blue wallet SVG as data URL -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M21 12V7H5a2 2 0 0 1 0-4h14v4'/%3E%3Cpath d='M3 5v14a2 2 0 0 0 2 2h16v-5'/%3E%3Cpath d='M18 12a2 2 0 0 0 0 4h4v-4Z'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        ::-webkit-scrollbar { width: 8px; height: 8px;}
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .page { display: none; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .data-table th, .data-table td { padding: 12px 15px; text-align: left; vertical-align: middle; }
        .data-table thead { background-color: #f8fafc; }
        .data-table tbody tr:nth-child(even) { background-color: #f8fafc; }
        .modal.hidden { display: none; }
        .category-select {
            width: 100%;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }
        .category-select:disabled {
            background-color: #f3f4f6;
            cursor: not-allowed;
        }
        .icon-btn {
            background: none;
            border: none;
            padding: 2px;
            cursor: pointer;
        }
        .pivot-table td, .pivot-table th {
            white-space: nowrap;
            padding: 8px 12px;
        }
        .pivot-table .drillable {
            cursor: pointer;
            color: #2563eb;
            font-weight: 500;
        }
         .pivot-table .drillable:hover {
            text-decoration: underline;
        }
        #top-scrollbar-container {
            overflow-x: auto;
            overflow-y: hidden;
        }
         #top-scrollbar-container::-webkit-scrollbar {
            background: transparent; /* Makes the track invisible */
        }
         #top-scrollbar-container::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* Keeps the thumb visible */
        }
        .toggle-icon {
            display: inline-block;
            width: 1rem;
            margin-right: 0.25rem;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .toggle-icon.expanded {
            transform: rotate(90deg);
        }

        /* --- Sticky Column CSS --- */
        .pivot-table th:first-child,
        .pivot-table td:first-child {
            position: -webkit-sticky; /* For Safari */
            position: sticky;
            left: 0;
            z-index: 10;
            border-right: 1px solid #e2e8f0; /* A subtle border for visual separation */
        }
        .pivot-table thead th:first-child {
            background-color: #f8fafc; /* Matches header background */
        }
        .pivot-table tbody td:first-child {
            background-color: #ffffff; /* Default row background */
        }
        .data-table tbody tr:nth-child(even) td:first-child { background-color: #f8fafc; }
        .pivot-table tfoot td:first-child {
            background-color: #e5e7eb; /* Matches the tfoot tr background-color */
        }
        /* --- End Sticky Column CSS --- */
        
        .hidden {
             display: none !important;
        }
        .report-row.hidden {
            display: none;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            display: inline-block;
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #1d4ed8;
            animation: spin 1s ease-in-out infinite;
        }
    </style>
</head>
<body class="bg-slate-100">

    <div id="main-app" class="flex h-screen bg-gray-100">
        <aside class="w-64 flex flex-col bg-white shadow-lg">
            <div class="flex items-center justify-center h-20 shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-8 w-8 text-blue-600"><path d="M21 12V7H5a2 2 0 0 1 0-4h14v4"></path><path d="M3 5v14a2 2 0 0 0 2 2h16v-5"></path><path d="M18 12a2 2 0 0 0 0 4h4v-4Z"></path></svg>
                <h1 class="text-2xl font-bold text-gray-800 ml-2">FinTrack</h1>
            </div>
            <nav class="flex-grow pt-5">
                <ul class="flex flex-col space-y-2 px-4">
                    <li><a href="#" class="nav-link active flex items-center p-3 text-gray-700 bg-blue-100 rounded-lg" onclick="showPage('dashboard')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5"><rect width="7" height="9" x="3" y="3" rx="1"></rect><rect width="7" height="5" x="14" y="3" rx="1"></rect><rect width="7" height="9" x="14" y="12" rx="1"></rect><rect width="7" height="5" x="3" y="16" rx="1"></rect></svg><span class="ml-3">Dashboard</span></a></li>
                    <li><a href="#" class="nav-link flex items-center p-3 text-gray-600 hover:bg-gray-200 rounded-lg" onclick="showPage('transactions')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5"><line x1="12" x2="12" y1="2" y2="22"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg><span class="ml-3">Transactions</span></a></li>
                    <li><a href="#" class="nav-link flex items-center p-3 text-gray-600 hover:bg-gray-200 rounded-lg" onclick="showPage('rules')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg><span class="ml-3">Rules</span></a></li>
                    <li><a href="#" class="nav-link flex items-center p-3 text-gray-600 hover:bg-gray-200 rounded-lg" onclick="showPage('reports')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg><span class="ml-3">Reports</span></a></li>
                    <li><a href="#" class="nav-link flex items-center p-3 text-gray-600 hover:bg-gray-200 rounded-lg" onclick="showPage('categories')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg><span class="ml-3">Categories</span></a></li>
                    <li><a href="#" class="nav-link flex items-center p-3 text-gray-600 hover:bg-gray-200 rounded-lg" onclick="showPage('settings')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2.4l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2.4l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg><span class="ml-3">Settings</span></a></li>
                </ul>
            </nav>
        </aside>

        <main class="flex-1 p-6 sm:p-10 overflow-y-auto">

            <div id="dashboard-page" class="page" style="display: block;">
                <h2 class="text-3xl font-semibold text-gray-800 mb-6">Dashboard</h2>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="font-semibold text-gray-600">This Year's Spend</h3>
                        <div class="flex items-baseline space-x-2">
                             <p class="text-3xl font-bold text-gray-800 mt-2" id="total-spend">$0.00</p>
                             <span id="ytd-comparison" class="text-sm font-medium"></span>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md"><h3 class="font-semibold text-gray-600">Top 5 Spending Categories</h3><div id="top-category" class="mt-2"></div></div>
                    <div id="review-card" class="bg-white p-6 rounded-lg shadow-md hover:bg-gray-50 cursor-pointer transition-colors duration-200" onclick="handleReviewClick()">
                        <div class="flex justify-between items-start">
                            <h3 class="font-semibold text-gray-600">Transactions to Review</h3>
                            <span id="review-card-label" class="text-xs font-medium bg-blue-100 text-blue-800 px-2 py-1 rounded-full" style="display: none;">Click to review</span>
                        </div>
                        <p class="text-3xl font-bold text-gray-800 mt-2" id="review-count">0</p>
                    </div>

                    <div class="lg:col-span-3 bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-xl font-semibold text-gray-800 mb-4">Monthly Spending Trends</h3>
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4 items-end">
                            <div>
                                <label for="dashboard-filter-type" class="block text-sm font-medium text-gray-700">Type</label>
                                <select id="dashboard-filter-type" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                            </div>
                            <div>
                                <label for="dashboard-filter-category" class="block text-sm font-medium text-gray-700">Category</label>
                                <select id="dashboard-filter-category" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                            </div>
                            <div>
                                <label for="dashboard-filter-subcategory" class="block text-sm font-medium text-gray-700">Sub-category</label>
                                <select id="dashboard-filter-subcategory" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                            </div>
                            <div class="flex items-center space-x-4">
                               <div class="flex items-center">
                                    <input id="compare-year-checkbox" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                    <label for="compare-year-checkbox" class="ml-2 block text-sm text-gray-900">Compare Previous Year</label>
                               </div>
                            </div>
                        </div>
                        <div style="height: 350px;">
                             <canvas id="monthly-spending-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div id="transactions-page" class="page">
                 <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6">
                    <h2 class="text-3xl font-semibold text-gray-800 mb-4 sm:mb-0" id="transactions-title">Transactions</h2>
                    <div class="flex items-center space-x-2 flex-wrap">
                         <input type="file" id="csv-importer" accept=".csv" class="hidden">
                        <button id="import-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                            Import CSV
                        </button>
                    </div>
                </div>
                
                <div id="filter-controls" class="bg-white p-4 rounded-lg shadow-md mb-6 space-y-4">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                         <div>
                            <label for="filter-start-date" class="block text-sm font-medium text-gray-700">Start Date</label>
                            <input type="date" id="filter-start-date" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm">
                        </div>
                        <div>
                            <label for="filter-end-date" class="block text-sm font-medium text-gray-700">End Date</label>
                            <input type="date" id="filter-end-date" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm">
                        </div>
                        <div>
                            <label for="filter-keyword" class="block text-sm font-medium text-gray-700">Keyword Search</label>
                            <input type="text" id="filter-keyword" placeholder="e.g., Amazon" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm">
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                        <div>
                             <label for="filter-type" class="block text-sm font-medium text-gray-700">Type</label>
                            <select id="filter-type" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                        </div>
                        <div>
                             <label for="filter-category" class="block text-sm font-medium text-gray-700">Category</label>
                            <select id="filter-category" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                        </div>
                         <div>
                             <label for="filter-subcategory" class="block text-sm font-medium text-gray-700">Sub-category</label>
                            <select id="filter-subcategory" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                        </div>
                        <div class="col-span-1 md:col-span-2 flex space-x-2">
                             <button id="apply-filters-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg w-full text-sm">Apply</button>
                             <button id="clear-filters-btn" class="bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg w-full text-sm">Clear</button>
                        </div>
                    </div>
                </div>

                <div class="bg-white p-4 rounded-lg shadow-md mb-6 flex items-center justify-end">
                    <div id="import-status" class="text-sm font-medium"></div>
                </div>
                
                <div id="transactions-container" class="bg-white rounded-lg shadow-md overflow-hidden"><p class="text-gray-500 text-center p-10">Your transactions will appear here after import.</p></div>
                <div id="pagination-controls" class="py-4 flex justify-center items-center space-x-4"></div>
            </div>
            
            <div id="rules-page" class="page">
                <h2 class="text-3xl font-semibold text-gray-800 mb-6">Categorization Rules</h2>
                 <div class="bg-white p-4 rounded-lg shadow-md mb-6 space-y-4">
                    <!-- Rules Filter Section -->
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                      <div>
                        <label for="rule-search-keyword" class="block text-sm font-medium text-gray-700">Search by Keyword</label>
                        <input type="text" id="rule-search-keyword" placeholder="e.g., Netflix" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm">
                      </div>
                      <div>
                        <label for="rule-filter-type" class="block text-sm font-medium text-gray-700">Filter by Type</label>
                        <select id="rule-filter-type" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                      </div>
                      <div>
                        <label for="rule-filter-category" class="block text-sm font-medium text-gray-700">Filter by Category</label>
                        <select id="rule-filter-category" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                      </div>
                      <div>
                        <label for="rule-filter-subcategory" class="block text-sm font-medium text-gray-700">Filter by SubCategory</label>
                        <select id="rule-filter-subcategory" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                      </div>
                      <div class="md:col-span-4 flex justify-end mt-2">
                        <button id="rule-filter-reset" class="bg-gray-200 text-gray-800 font-bold py-1 px-3 rounded-lg text-xs">Reset</button>
                      </div>
                    </div>
                </div>
                <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-lg font-medium text-gray-900 mb-4">Add a New Rule</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">IF description contains:</label>
                                <input type="text" id="rule-keyword" placeholder="e.g., Netflix" class="mt-1 flex-grow block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">THEN set Type to:</label>
                                <select id="rule-type" class="category-select mt-1"></select>
                            </div>
                             <div>
                                <label class="block text-sm font-medium text-gray-700">and Category to:</label>
                                <select id="rule-category" class="category-select mt-1"></select>
                            </div>
                             <div>
                                <label class="block text-sm font-medium text-gray-700">and Sub-category to:</label>
                                <select id="rule-subcategory" class="category-select mt-1"></select>
                            </div>
                            <div class="flex justify-end">
                                 <button id="add-rule-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300">Add Rule</button>
                            </div>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md">
                         <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-medium text-gray-900">Your Rules</h3>
                            <span id="rules-count" class="text-sm font-normal text-gray-500"></span>
                         </div>
                         <div id="rules-list-container" class="mt-4 max-h-96 overflow-y-auto">
                            </div>
                    </div>
                </div>
            </div>

            <div id="reports-page" class="page">
                <h2 class="text-3xl font-semibold text-gray-800 mb-6">Spending Report</h2>
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <div class="space-y-4 mb-6">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
                            <div>
                                <label for="report-start-date" class="block text-sm font-medium text-gray-700">Start Date</label>
                                <input type="date" id="report-start-date" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm">
                            </div>
                            <div>
                                <label for="report-end-date" class="block text-sm font-medium text-gray-700">End Date</label>
                                <input type="date" id="report-end-date" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm">
                            </div>
                             <div class="flex items-center space-x-4">
                                <span class="text-sm font-medium text-gray-700">Group By:</span>
                                <label class="flex items-center"><input type="radio" name="group-by" value="month" checked class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"><span class="ml-2">Month</span></label>
                                <label class="flex items-center"><input type="radio" name="group-by" value="year" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"><span class="ml-2">Year</span></label>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <label for="report-filter-type" class="block text-sm font-medium text-gray-700">Type</label>
                                <select id="report-filter-type" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                            </div>
                            <div>
                                <label for="report-filter-category" class="block text-sm font-medium text-gray-700">Category</label>
                                <select id="report-filter-category" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                            </div>
                            <div>
                                <label for="report-filter-subcategory" class="block text-sm font-medium text-gray-700">Sub-category</label>
                                <select id="report-filter-subcategory" class="mt-1 w-full rounded-md border-gray-300 shadow-sm text-sm"></select>
                            </div>
                        </div>
                         <div class="flex items-end space-x-2">
                            <button id="generate-report-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg w-full">Generate Report</button>
                            <button id="export-excel-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 flex items-center w-auto hidden"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M12 18h-1v-5h1v2h1v1h-1v2Z"></path><path d="M18 18h-1v-5h1v5Z"></path><path d="m15 15-3-3 3-3"></path></svg>Export</button>
                        </div>
                    </div>
                    <div id="report-container">
                        <div id="top-scrollbar-container" class="overflow-x-auto">
                            <div id="top-scrollbar-content" style="height: 1px;"></div>
                        </div>
                        <div id="report-output" class="overflow-x-auto">
                            <p class="text-gray-500 text-center p-10">Generate a report to see your spending analysis.</p>
                        </div>
                    </div>
                </div>
            </div>


            <div id="categories-page" class="page">
                <h2 class="text-3xl font-semibold text-gray-800 mb-6">Manage Categories</h2>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-lg font-medium text-gray-900 mb-4">Add a New Category</h3>
                        <div class="space-y-4">
                            <div>
                                <label for="new-type-input" class="block text-sm font-medium text-gray-700">Type</label>
                                <input type="text" id="new-type-input" placeholder="e.g., Household" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                            </div>
                            <div>
                                <label for="new-category-input" class="block text-sm font-medium text-gray-700">Category</label>
                                <input type="text" id="new-category-input" placeholder="e.g., Groceries" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                            </div>
                            <div>
                                <label for="new-subcategory-input" class="block text-sm font-medium text-gray-700">Sub-category (Optional)</label>
                                <input type="text" id="new-subcategory-input" placeholder="e.g., Gas" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                            </div>
                            <div class="flex justify-end">
                                <button id="add-category-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300">Add</button>
                            </div>
                        </div>
                        <div id="category-status" class="text-sm mt-2"></div>
                        <!-- Export/Import Buttons -->
                        <div class="mt-6 flex flex-wrap gap-2">
                            <button id="export-categories-csv-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Export Categories (CSV)</button>
                            <button id="export-categories-json-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Export Categories (JSON)</button>
                            <input type="file" id="import-categories-csv-input" accept=".csv" class="hidden">
                            <button id="import-categories-csv-btn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700">Import Categories (CSV)</button>
                            <input type="file" id="import-category-mapping-json-input" accept=".json" class="hidden">
                            <button id="import-category-mapping-json-btn" class="bg-orange-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-700">Import Category Mapping (JSON)</button>
                        </div>
                        <!-- Help Section for Export/Import JSON -->
                        <div class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg text-sm text-gray-800">
                            <div class="font-semibold mb-2 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
                                <span>How to Use Export/Import for Category Consolidation</span>
                            </div>
                            <ol class="list-decimal ml-6 mb-2">
                                <li><b>Export Categories (JSON):</b> Click to download your current category hierarchy as a JSON file.</li>
                                <li><b>Consolidate with AI:</b> Copy the exported JSON and paste it into Gemini or ChatGPT using the prompt below. The AI will return a mapping for consolidation.</li>
                                <li><b>Import Category Mapping (JSON):</b> Download the AI's mapping as a JSON file and import it here. This will update all categories, rules, and transactions according to the mapping.</li>
                            </ol>
                            <div class="mb-1 font-semibold">Copy &amp; paste this prompt into Gemini or ChatGPT:</div>
                            <textarea readonly class="w-full p-2 rounded bg-blue-100 border border-blue-200 text-xs font-mono mb-2" rows="7" onclick="this.select()">Analyze the following category hierarchy. Consolidate similar categories into a more logical structure. For example, merge 'Food > Restaurants', 'Lifestyle > Dining', and 'Food+Drink > DiningOut' into something like 'Food > Dining > Restaurant'.

Current Hierarchy:
<PASTE YOUR EXPORTED JSON HERE>

Return ONLY a JSON object containing one key: 'mapping'.
The value of 'mapping' should be an array that maps EVERY original category and sub-category to its new path. Each item in the array should have an 'old' and 'new' object, each with 'type', 'category', and 'subCategory' fields. It is critical that every single original category from the 'Current Hierarchy' is present in the 'old' part of the mapping. If a category is not changed, its 'old' and 'new' values should be identical.
Ensure the entire output is a single, valid JSON object.</textarea>
                            <div class="text-xs text-gray-600">Tip: After AI returns the mapping, download it as a .json file and use <b>Import Category Mapping (JSON)</b> to apply it.</div>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-medium text-gray-900">Your Categories</h3>
                            <span id="categories-count" class="text-sm font-normal text-gray-500"></span>
                        </div>
                        <div id="categories-list-container" class="mt-4"></div>
                    </div>
                </div>
            </div>

            <div id="settings-page" class="page">
                <h2 class="text-3xl font-semibold text-gray-800 mb-6">Settings</h2>
                <div class="space-y-8">
                     <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-lg font-medium text-gray-900 mb-2">Google AI API Key</h3>
                        <p class="text-sm text-gray-600 mb-4">
                            The AI categorization feature requires a Google AI API Key. You can get a free key from 
                            <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 hover:underline">Google AI Studio</a>. 
                            The key is stored only in your browser's local storage.
                        </p>
                        <div class="flex items-center space-x-2">
                            <input type="password" id="api-key-input" placeholder="Enter your API Key" class="flex-grow block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                            <button id="save-api-key-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Save</button>
                        </div>
                        <p id="api-key-status" class="text-sm mt-2"></p>
                    </div>
                     <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-lg font-medium text-gray-900 mb-2">Backup & Restore</h3>
                        <div class="flex space-x-4">
                            <button id="export-backup-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Export All Data</button>
                            <input type="file" id="backup-importer" class="hidden" accept=".json">
                            <label for="backup-importer" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 cursor-pointer">Import Backup</label>
                        </div>
                    </div>

                     <div class="bg-white p-6 rounded-lg shadow-md">
                        <h3 class="text-lg font-medium text-red-700 mb-2">Danger Zone</h3>
                        <p class="text-sm text-gray-600 mb-4">This will permanently delete all transactions, categories, and rules from the application. This action cannot be undone.</p>
                        <button id="purge-data-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 transition duration-300 flex items-center">
                           <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5 mr-2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg>
                            Purge All Data
                        </button>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <!-- Mapping Modal -->
    <div id="mapping-modal" class="modal fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl">
            <h2 class="text-2xl font-bold mb-4">Map Your CSV Columns</h2>
            <p class="text-gray-600 mb-6">Please match the columns from your CSV file to the required application fields.</p>
            <div id="mapping-fields-container" class="space-y-4">
                </div>
            <div class="mt-8 flex justify-end space-x-4">
                <button id="cancel-mapping-btn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="process-file-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Process File</button>
            </div>
        </div>
    </div>
    
    <!-- API Key Modal -->
    <div id="api-key-modal" class="modal fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h2 class="text-2xl font-bold mb-4">API Key Required</h2>
            <p class="text-gray-600 mb-4">
                To automatically categorize your first import, please provide a Google AI API Key. You can get a free key from 
                <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 hover:underline">Google AI Studio</a>.
            </p>
            <div class="space-y-2">
                 <label for="modal-api-key-input" class="block text-sm font-medium text-gray-700">Your API Key</label>
                 <input type="password" id="modal-api-key-input" placeholder="Enter your API Key" class="flex-grow block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
            </div>
            <div class="mt-8 flex justify-end space-x-4">
                <button id="cancel-api-key-modal-btn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">Cancel Import</button>
                <button id="save-and-retry-api-key-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Save & Continue Import</button>
            </div>
        </div>
    </div>

    <!-- New Category Modal (from transaction screen) -->
    <div id="new-category-modal" class="modal fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h2 class="text-2xl font-bold mb-4">Create New Category</h2>
            <p class="text-gray-600 mb-6">Create a new category on the fly. It will be applied to the current transaction.</p>
            <div class="space-y-4">
                <input type="hidden" id="modal-tx-index">
                <div>
                    <label for="modal-new-type" class="block text-sm font-medium text-gray-700">Type</label>
                    <input type="text" id="modal-new-type" placeholder="e.g., Household" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                </div>
                <div>
                    <label for="modal-new-category" class="block text-sm font-medium text-gray-700">Category</label>
                    <input type="text" id="modal-new-category" placeholder="e.g., Groceries" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                </div>
                <div>
                    <label for="modal-new-subcategory" class="block text-sm font-medium text-gray-700">Sub-category (Optional)</label>
                    <input type="text" id="modal-new-subcategory" placeholder="e.g., Gas" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm sm:text-sm">
                </div>
            </div>
            <div id="modal-category-status" class="text-sm mt-2"></div>
            <div class="mt-8 flex justify-end space-x-4">
                <button id="cancel-new-category-btn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="save-new-category-btn" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">Create & Apply</button>
            </div>
        </div>
    </div>

    <!-- Import Options Modal -->
    <div id="import-options-modal" class="modal fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center hidden">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-lg">
            <h2 class="text-2xl font-bold mb-4">Import Options</h2>
            <p class="text-gray-600 mb-6">How would you like to categorize the transactions in this file?</p>
            <div class="space-y-4">
                <button id="import-with-ai-btn" class="bg-purple-600 text-white font-bold py-3 px-4 rounded-lg w-full flex items-center justify-center text-left">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-6 w-6 mr-3"><path d="M15.042 21.672L13.684 16.6m0 0l-2.5-2.5m2.5 2.5l2.5 2.5M16.6 13.684l5.072-1.458M16.6 13.684l-2.5-2.5m2.5 2.5l2.5 2.5m-5.072-5.072l1.458-5.072M13.684 8.4l2.5 2.5m-2.5-2.5l-2.5-2.5m-2.5 2.5l-2.5 2.5M8.4 13.684l-5.072 1.458M8.4 13.684l2.5 2.5m-2.5-2.5L3.328 8.4m5.072 5.284l2.5-2.5m-2.5 2.5l-2.5 2.5m5.072-5.072l-1.458 5.072"/></svg>
                    <div>
                        <span class="font-bold">Use AI to Categorize</span>
                        <span class="block text-xs text-purple-200">Best for first import or when adding many new expense types.</span>
                    </div>
                </button>
                <button id="import-with-rules-btn" class="bg-blue-600 text-white font-bold py-3 px-4 rounded-lg w-full flex items-center justify-center text-left">
                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-6 w-6 mr-3"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>
                     <div>
                        <span class="font-bold">Use Existing Rules Only</span>
                        <span class="block text-xs text-blue-200">Fastest option. Unmatched items will need manual review.</span>
                    </div>
                </button>
            </div>
             <div class="mt-8 flex justify-end">
                <button id="cancel-import-options-btn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300">Cancel</button>
            </div>
        </div>
    </div>

    <!-- AI Progress Modal -->
    <div id="ai-progress-modal" class="modal fixed inset-0 bg-gray-600 bg-opacity-75 overflow-y-auto h-full w-full flex items-center justify-center hidden">
        <div class="bg-white p-10 rounded-lg shadow-xl text-center">
            <div class="spinner mx-auto mb-6"></div>
            <h2 class="text-xl font-bold text-gray-800 mb-2">AI In Progress...</h2>
            <p id="ai-status-message" class="text-gray-600">Categorizing your transactions. Please wait.</p>
        </div>
    </div>
    
    <script>
        // --- Global State ---
        let transactionsDB = [];
        let categoryHierarchy = {};
        let rulesDB = [];
        let existingTransactionKeys = new Set();
        let importContext = { fileContent: null, pausedMapping: null };
        let isReviewMode = false;
        let lastReportData = { headers: [], rows: [] };
        let monthlySpendingChart = null;
        let transactionCurrentPage = 1;
        const transactionsPerPage = 50;
        let currentlyDisplayedTransactions = [];

        // --- DOM Element References ---
        const purgeDataBtn = document.getElementById('purge-data-btn');
        const importBtn = document.getElementById('import-btn');
        const csvImporter = document.getElementById('csv-importer');
        const transactionsContainer = document.getElementById('transactions-container');
        const transactionsTitle = document.getElementById('transactions-title');
        const importStatus = document.getElementById('import-status');
        const totalSpendEl = document.getElementById('total-spend');
        const topCategoryEl = document.getElementById('top-category');
        const reviewCountEl = document.getElementById('review-count');
        const reviewCardLabel = document.getElementById('review-card-label');
        const addCategoryBtn = document.getElementById('add-category-btn');
        const categoriesListContainer = document.getElementById('categories-list-container');
        const categoryStatus = document.getElementById('category-status');
        const categoriesCount = document.getElementById('categories-count');
        const mappingModal = document.getElementById('mapping-modal');
        const mappingFieldsContainer = document.getElementById('mapping-fields-container');
        const cancelMappingBtn = document.getElementById('cancel-mapping-btn');
        const processFileBtn = document.getElementById('process-file-btn');
        const addRuleBtn = document.getElementById('add-rule-btn');
        const ruleKeywordInput = document.getElementById('rule-keyword');
        const ruleTypeSelect = document.getElementById('rule-type');
        const ruleCategorySelect = document.getElementById('rule-category');
        const ruleSubcategorySelect = document.getElementById('rule-subcategory');
        const rulesListContainer = document.getElementById('rules-list-container');
        const rulesCount = document.getElementById('rules-count');
        const generateReportBtn = document.getElementById('generate-report-btn');
        const reportOutput = document.getElementById('report-output');
        const exportExcelBtn = document.getElementById('export-excel-btn');
        const paginationControls = document.getElementById('pagination-controls');
        const aiProgressModal = document.getElementById('ai-progress-modal');
        const aiStatusMessage = document.getElementById('ai-status-message');
        // API Key Elements
        const apiKeyModal = document.getElementById('api-key-modal');
        const apiKeyInput = document.getElementById('api-key-input');
        const modalApiKeyInput = document.getElementById('modal-api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const apiKeyStatus = document.getElementById('api-key-status');
        const cancelApiKeyModalBtn = document.getElementById('cancel-api-key-modal-btn');
        const saveAndRetryApiKeyBtn = document.getElementById('save-and-retry-api-key-btn');
        // New Category Modal Elements
        const newCategoryModal = document.getElementById('new-category-modal');
        const modalTxIndexInput = document.getElementById('modal-tx-index');
        const modalNewTypeInput = document.getElementById('modal-new-type');
        const modalNewCategoryInput = document.getElementById('modal-new-category');
        const modalNewSubcategoryInput = document.getElementById('modal-new-subcategory');
        const cancelNewCategoryBtn = document.getElementById('cancel-new-category-btn');
        const saveNewCategoryBtn = document.getElementById('save-new-category-btn');
        const modalCategoryStatus = document.getElementById('modal-category-status');
        // Import Options Modal
        const importOptionsModal = document.getElementById('import-options-modal');
        const importWithAiBtn = document.getElementById('import-with-ai-btn');
        const importWithRulesBtn = document.getElementById('import-with-rules-btn');
        const cancelImportOptionsBtn = document.getElementById('cancel-import-options-btn');
        // Filter Controls
        const filterControls = document.getElementById('filter-controls');
        const filterTypeSelect = document.getElementById('filter-type');
        const filterCategorySelect = document.getElementById('filter-category');
        const filterSubCategorySelect = document.getElementById('filter-subcategory');
        const applyFiltersBtn = document.getElementById('apply-filters-btn');
        const clearFiltersBtn = document.getElementById('clear-filters-btn');
        const reportFilterType = document.getElementById('report-filter-type');
        const reportFilterCategory = document.getElementById('report-filter-category');
        const reportFilterSubcategory = document.getElementById('report-filter-subcategory');
        // Dashboard Chart Controls
        const dashboardFilterType = document.getElementById('dashboard-filter-type');
        const dashboardFilterCategory = document.getElementById('dashboard-filter-category');
        const dashboardFilterSubcategory = document.getElementById('dashboard-filter-subcategory');
        const compareYearCheckbox = document.getElementById('compare-year-checkbox');
        // Add after DOM element references:
        const exportCategoriesCsvBtn = document.getElementById('export-categories-csv-btn');
        const exportCategoriesJsonBtn = document.getElementById('export-categories-json-btn');
        const importCategoriesCsvBtn = document.getElementById('import-categories-csv-btn');
        const importCategoriesCsvInput = document.getElementById('import-categories-csv-input');
        const importCategoryMappingJsonBtn = document.getElementById('import-category-mapping-json-btn');
        const importCategoryMappingJsonInput = document.getElementById('import-category-mapping-json-input');
        // Add after DOM element references:
        const ruleSearchKeywordInput = document.getElementById('rule-search-keyword');
        const ruleFilterCategorySelect = document.getElementById('rule-filter-category');
        const exportBackupBtn = document.getElementById('export-backup-btn');
        const backupImporter = document.getElementById('backup-importer');
        const ruleFilterTypeEl = document.getElementById('rule-filter-type');
        const ruleFilterCategoryEl = document.getElementById('rule-filter-category');
        const ruleFilterSubCategoryEl = document.getElementById('rule-filter-subcategory');
        const ruleFilterResetBtn = document.getElementById('rule-filter-reset');

        // --- Data Persistence ---
        function saveDataToLocal() {
            try {
                localStorage.setItem('fintrack_transactions', JSON.stringify(transactionsDB));
                localStorage.setItem('fintrack_categories', JSON.stringify(categoryHierarchy));
                localStorage.setItem('fintrack_rules', JSON.stringify(rulesDB));
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
                if (e && e.name === 'QuotaExceededError') {
                    alert("Could not save data: Local storage quota exceeded. Please export and clear some data.");
                } else {
                    alert("Could not save data. See console for details.");
                }
            }
        }

        function loadDataFromLocal() {
            const savedTransactions = localStorage.getItem('fintrack_transactions');
            if (savedTransactions) { transactionsDB = JSON.parse(savedTransactions); existingTransactionKeys = new Set(transactionsDB.map(tx => tx.id)); }
            const savedCategories = localStorage.getItem('fintrack_categories');
            if (savedCategories) { categoryHierarchy = JSON.parse(savedCategories); }
            const savedRules = localStorage.getItem('fintrack_rules');
            if (savedRules) { rulesDB = JSON.parse(savedRules); }
            
            // Load API Key into settings input for visibility
            const savedApiKey = localStorage.getItem('fintrack_apiKey');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
            }
        }
        
        // --- API Key Management ---
        function getApiKey() {
            return localStorage.getItem('fintrack_apiKey') || '';
        }

        function saveApiKey() {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem('fintrack_apiKey', key);
                apiKeyStatus.textContent = 'API Key saved successfully!';
                apiKeyStatus.className = 'text-sm mt-2 text-green-600';
            } else {
                localStorage.removeItem('fintrack_apiKey');
                apiKeyStatus.textContent = 'API Key cleared.';
                apiKeyStatus.className = 'text-sm mt-2 text-yellow-600';
            }
            setTimeout(() => { apiKeyStatus.textContent = ''; }, 3000);
        }
        
        function showApiKeyModal(mapping) {
            importContext.pausedMapping = mapping;
            apiKeyModal.classList.remove('hidden');
        }

        // --- Initial Load ---
        window.onload = () => {
            loadDataFromLocal();
            // Populate all dropdowns once on load
            populateAllDropdowns();
            
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('report-end-date').value = today;
            const lastYear = new Date();
            lastYear.setFullYear(lastYear.getFullYear() - 1);
            document.getElementById('report-start-date').value = lastYear.toISOString().split('T')[0];

            // Initial render
            showPage('dashboard'); 
        };
        
        // --- Event Listeners ---
        purgeDataBtn.addEventListener('click', handlePurgeData);
        importBtn.addEventListener('click', () => csvImporter.click());
        csvImporter.addEventListener('change', (event) => handleFileSelect(event, prepareFileImport));
        addCategoryBtn.addEventListener('click', handleAddCategory);
        cancelMappingBtn.addEventListener('click', () => mappingModal.classList.add('hidden'));
        processFileBtn.addEventListener('click', processMappedFile);
        addRuleBtn.addEventListener('click', handleAddRule);
        ruleTypeSelect.addEventListener('change', () => populateRuleDropdowns('category'));
        ruleCategorySelect.addEventListener('change', () => populateRuleDropdowns('subcategory'));
        generateReportBtn.addEventListener('click', generateReport);
        exportExcelBtn.addEventListener('click', exportReportToExcel);
        applyFiltersBtn.addEventListener('click', () => {
            transactionCurrentPage = 1;
            renderTransactionTable();
        });
        clearFiltersBtn.addEventListener('click', () => {
            filterControls.querySelectorAll('input[type="date"]').forEach(el => el.value = '');
            populateFilterDropdowns();
            transactionCurrentPage = 1;
            renderTransactionTable();
        });
        filterTypeSelect.addEventListener('change', () => populateFilterDropdowns('category'));
        filterCategorySelect.addEventListener('change', () => populateFilterDropdowns('subcategory'));
        reportFilterType.addEventListener('change', () => populateReportFilterDropdowns('category'));
        reportFilterCategory.addEventListener('change', () => populateReportFilterDropdowns('subcategory'));
        // Dashboard chart filter listeners
        dashboardFilterType.addEventListener('change', () => {
            populateDashboardFilterDropdowns('category');
            renderDashboardChart();
        });
        dashboardFilterCategory.addEventListener('change', () => {
            populateDashboardFilterDropdowns('subcategory');
            renderDashboardChart();
        });
        dashboardFilterSubcategory.addEventListener('change', renderDashboardChart);
        compareYearCheckbox.addEventListener('change', renderDashboardChart);
        // API Key Listeners
        saveApiKeyBtn.addEventListener('click', saveApiKey);
        cancelApiKeyModalBtn.addEventListener('click', () => {
            apiKeyModal.classList.add('hidden');
            importContext.pausedMapping = null; // Clear the paused state
        });
        saveAndRetryApiKeyBtn.addEventListener('click', () => {
            const key = modalApiKeyInput.value.trim();
            if (key) {
                apiKeyInput.value = key; // Also update the settings page input
                saveApiKey();
                apiKeyModal.classList.add('hidden');
                if (importContext.pausedMapping) {
                    processMappedFile(); // This will re-trigger the check
                }
            } else {
                alert("Please enter a valid API key.");
            }
        });
        // New Category Modal Listeners
        cancelNewCategoryBtn.addEventListener('click', () => {
            newCategoryModal.classList.add('hidden');
            renderTransactionTable();
        });
        saveNewCategoryBtn.addEventListener('click', handleSaveNewCategory);
        // Import Options Modal Listeners
        cancelImportOptionsBtn.addEventListener('click', () => importOptionsModal.classList.add('hidden'));
        importWithAiBtn.addEventListener('click', () => processWithAI(importContext.pausedMapping));
        importWithRulesBtn.addEventListener('click', () => processStandardImport(importContext.pausedMapping));
        // Export/Import Buttons
        exportCategoriesCsvBtn.addEventListener('click', exportCategoriesAsCSV);
        exportCategoriesJsonBtn.addEventListener('click', exportCategoriesAsJSON);
        importCategoriesCsvBtn.addEventListener('click', () => importCategoriesCsvInput.click());
        importCategoriesCsvInput.addEventListener('change', handleImportCategoriesCSV);
        importCategoryMappingJsonBtn.addEventListener('click', () => importCategoryMappingJsonInput.click());
        importCategoryMappingJsonInput.addEventListener('change', handleImportCategoryMappingJSON);
        // Add event listeners:
        ruleSearchKeywordInput.addEventListener('input', renderRulesTable);
        ruleFilterCategorySelect.addEventListener('change', renderRulesTable);
        exportBackupBtn.addEventListener('click', () => {
            const backup = {
                transactions: transactionsDB,
                categories: categoryHierarchy,
                rules: rulesDB
            };
            const jsonStr = JSON.stringify(backup, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'FinTrack_Backup.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
        backupImporter.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backup = JSON.parse(e.target.result);
                    if (backup.transactions && Array.isArray(backup.transactions)) {
                        transactionsDB = backup.transactions;
                        existingTransactionKeys = new Set(transactionsDB.map(tx => tx.id));
                    }
                    if (backup.categories && typeof backup.categories === 'object') {
                        categoryHierarchy = backup.categories;
                    }
                    if (backup.rules && Array.isArray(backup.rules)) {
                        rulesDB = backup.rules;
                    }
                    saveDataToLocal();
                    populateAllDropdowns();
                    renderAll();
                    setCategoryStatus('Backup imported successfully!', 'green');
                } catch (err) {
                    setCategoryStatus('Error importing backup. See console.', 'red');
                    console.error('Error importing backup:', err);
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        });

        // --- Core Application Logic ---

        function formatCurrency(value) {
            const number = Number(value) || 0;
            return `$${Math.abs(number).toFixed(2)}`;
        }

        function handleReviewClick() {
            const uncategorizedCount = transactionsDB.filter(tx => !tx.type || tx.type === 'Uncategorized' || !tx.category || tx.category === 'Uncategorized').length;
            if (uncategorizedCount > 0) {
                showPage('transactions', true);
            }
        }

        function handlePurgeData() {
            if (confirm("Are you sure you want to delete all data? This includes all transactions, categories, and rules. This action cannot be undone.")) {
                localStorage.removeItem('fintrack_transactions');
                localStorage.removeItem('fintrack_categories');
                localStorage.removeItem('fintrack_rules');
                localStorage.removeItem('fintrack_apiKey');
                location.reload();
            }
        }
        
        function standardizeDateString(dateStr) {
            if (!dateStr || typeof dateStr !== 'string') return null;
            const s = dateStr.trim();
            const datePart = s.split(' ')[0];
            const parts = datePart.split(/[\/-]/);
            if (parts.length !== 3) { console.error(`Could not parse date: "${s}". Invalid parts.`); return null; }
            let year, month, day;
            if (parts[0].length === 4) { [year, month, day] = parts; }
            else if (parts[2].length === 4) { [day, month, year] = parts; }
            else if (parts[2].length === 2) { [day, month, year] = parts; year = "20" + year; }
            else { return null; }
            const testDate = new Date(`${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}T12:00:00Z`);
            if (isNaN(testDate.getTime())) { console.error(`Could not parse date: "${s}". Constructed date is invalid.`); return null; }
            return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        }

        function extractKeyword(description) {
            if (!description) return '';
            let cleanDescription = description.replace(/\s+[#\d-].*$/,'').trim();
            if (!cleanDescription) { cleanDescription = description; }
            // Allow asterisks in keywords
            cleanDescription = cleanDescription.replace(/[^a-zA-Z0-9\s\*]/g, ' ').replace(/\s+/g, ' ').trim();
            if (cleanDescription) { return cleanDescription.toUpperCase(); }
            return '';
        }

        function handleFileSelect(event, callback) {
            const file = event.target.files[0];
            if (file) {
                importStatus.textContent = 'Parsing file...';
                importStatus.className = 'text-sm font-medium text-gray-600';
                Papa.parse(file, { header: false, skipEmptyLines: true, complete: callback,
                    error: (err) => { importStatus.textContent = `Error parsing file: ${err.message}`; importStatus.className = 'text-sm font-medium text-red-600'; }
                });
            }
            event.target.value = null;
        }

        function cleanCurrency(value) {
            if (typeof value !== 'string') return '';
            return value.replace(/[^0-9.-]+/g, "");
        }
        
        function prepareFileImport(results) {
            importContext.fileContent = results.data;
            if (importContext.fileContent.length < 2) { alert("File appears to be empty or invalid."); return; }
            const headers = importContext.fileContent[0];
            let appFields = ['Date', 'Description', 'Debit Amount', 'Credit Amount'];
            
            mappingFieldsContainer.innerHTML = appFields.map(field => `
                <div class="grid grid-cols-3 gap-4 items-center">
                    <label class="font-semibold text-gray-700 col-span-1">${field}:</label>
                    <select id="map-${field.toLowerCase().replace(/ /g, '-')}" class="col-span-2 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                        <option value="">-- Not in file --</option>
                        ${headers.map(header => `<option value="${header}">${header}</option>`).join('')}
                    </select>
                </div>
            `).join('');
            mappingModal.classList.remove('hidden');
        }

        function processMappedFile() {
            const mapping = { 
                date: document.getElementById('map-date').value, 
                description: document.getElementById('map-description').value, 
                debitAmount: document.getElementById('map-debit-amount').value, 
                creditAmount: document.getElementById('map-credit-amount').value 
            };

            if (!mapping.date || !mapping.description || (!mapping.debitAmount && !mapping.creditAmount)) { 
                alert('Please map Date, Description, and at least one Amount column (Debit or Credit).'); 
                return; 
            }
            
            importContext.pausedMapping = mapping;
            mappingModal.classList.add('hidden');
            importOptionsModal.classList.remove('hidden');
        }

        async function processWithAI(mapping) {
            importOptionsModal.classList.add('hidden');
            const apiKey = getApiKey();
            if (!apiKey) {
                showApiKeyModal(mapping);
                return;
            }

            aiProgressModal.classList.remove('hidden');
            aiStatusMessage.textContent = 'Parsing new transactions...';
            
            const { newTransactions, duplicateCount, errorCount } = parseNewTransactions(mapping);
            
            if (newTransactions.length === 0) {
                aiProgressModal.classList.add('hidden');
                importStatus.textContent = `Import complete. ${duplicateCount} duplicates ignored. ${errorCount} rows failed.`;
                importStatus.className = 'text-sm font-medium text-yellow-600';
                return;
            }

            aiStatusMessage.textContent = 'Step 1/3: Applying existing rules...';
            let { categorized, unmatched } = applyExistingRules(newTransactions);
            let autoCategorizedCount = categorized.length;
            
            if (unmatched.length > 0) {
                aiStatusMessage.textContent = `Step 2/3: AI is categorizing ${unmatched.length} new transactions...`;
                const aiCategorized = await categorizeWithAI(unmatched, apiKey);
                categorized.push(...aiCategorized);
            }

            // Skipping AI consolidation step here
            // const tempHierarchy = buildTemporaryHierarchy(categorized);
            // const consolidationMap = await consolidateWithAI(tempHierarchy, apiKey);
            // applyConsolidation(consolidationMap);

            aiStatusMessage.textContent = 'Step 3/3: Finalizing import...';
            // Show spinner and allow UI to update
            setTimeout(() => {
                try {
                    generateNewRules(categorized);
                    transactionsDB.push(...newTransactions);
                    newTransactions.forEach(tx => existingTransactionKeys.add(tx.id));
                    // --- Build categoryHierarchy from all transactions ---
                    const newHierarchy = {};
                    transactionsDB.forEach(tx => {
                        if (!tx.type || tx.type === 'Uncategorized' || !tx.category || tx.category === 'Uncategorized') return;
                        if (!newHierarchy[tx.type]) newHierarchy[tx.type] = {};
                        if (!newHierarchy[tx.type][tx.category]) newHierarchy[tx.type][tx.category] = [];
                        if (tx.subCategory && !newHierarchy[tx.type][tx.category].includes(tx.subCategory)) {
                            newHierarchy[tx.type][tx.category].push(tx.subCategory);
                        }
                    });
                    categoryHierarchy = newHierarchy;
                    saveDataToLocal();
                    renderAll();
                    aiProgressModal.classList.add('hidden');
                    // Check if all transactions are still uncategorized
                    const uncategorizedCount = transactionsDB.filter(tx => !tx.type || tx.type === 'Uncategorized' || !tx.category || tx.category === 'Uncategorized').length;
                    const allUncategorized = uncategorizedCount === transactionsDB.length;
                    const categoryCount = Object.keys(categoryHierarchy).length;
                    let warningMsg = '';
                    if (allUncategorized) {
                        warningMsg = 'Warning: All transactions remain uncategorized after import. This may indicate an issue with the AI categorization step or your API key.';
                    } else if (rulesDB.length > 0 && categoryCount === 0) {
                        warningMsg = 'Warning: Rules were created but no categories were generated. Please check your AI output and category import format.';
                    }
                    importStatus.textContent = `Import complete! ${newTransactions.length} new txns added. ${autoCategorizedCount} matched by existing rules. ${duplicateCount} duplicates ignored.` + (warningMsg ? `\n${warningMsg}` : '');
                    importStatus.className = 'text-sm font-medium ' + (warningMsg ? 'text-yellow-600' : 'text-green-600');
                } catch (e) {
                    aiProgressModal.classList.add('hidden');
                    importStatus.textContent = 'An error occurred during finalizing import. See console for details.';
                    importStatus.className = 'text-sm font-medium text-red-600';
                    console.error('Error during finalizing import:', e);
                }
            }, 100); // Allow spinner to show
        }

        function parseNewTransactions(mapping) {
            const dataRows = [...importContext.fileContent];
            const header = dataRows.shift().map(h => h.trim().replace(/"/g, ''));
            const indices = { 
                date: header.indexOf(mapping.date), 
                description: header.indexOf(mapping.description), 
                debitAmount: header.indexOf(mapping.debitAmount), 
                creditAmount: header.indexOf(mapping.creditAmount) 
            };
            
            let newTransactions = [];
            let duplicateCount = 0;
            let errorCount = 0;

            dataRows.forEach((row, index) => {
                if (row.length !== header.length) { if (row.length === 1 && row[0] === "") return; errorCount++; return; }
                try {
                    const dateStr = row[indices.date]; const date = standardizeDateString(dateStr); const description = row[indices.description];
                    if (!date || !description) { throw new Error("Missing or invalid date/description"); }
                    let amount = 0; let amountFound = false;
                    const debitString = indices.debitAmount > -1 ? row[indices.debitAmount] : '';
                    if (debitString && debitString.trim() !== '') { const val = parseFloat(cleanCurrency(debitString)); if (!isNaN(val)) { amount = -Math.abs(val); amountFound = true; }}
                    if (!amountFound) { const creditString = indices.creditAmount > -1 ? row[indices.creditAmount] : ''; if (creditString && creditString.trim() !== '') { const val = parseFloat(cleanCurrency(creditString)); if (!isNaN(val)) { amount = Math.abs(val); amountFound = true; }}}
                    if (!amountFound) { throw new Error("No valid amount"); }
                    const transactionKey = `${date}-${description.trim()}-${amount}`;
                    if (existingTransactionKeys.has(transactionKey)) { duplicateCount++; return; }
                    
                    newTransactions.push({ 
                        id: transactionKey, date, description: description.trim(), amount, 
                        type: 'Uncategorized', category: 'Uncategorized', subCategory: ''
                    });
                } catch (e) { errorCount++; console.error(`Could not parse row ${index + 2}:`, row, e.message); }
            });

            return { newTransactions, duplicateCount, errorCount };
        }

        function applyExistingRules(transactions) {
            const categorized = [];
            const unmatched = [];
            transactions.forEach(tx => {
                let ruleFound = false;
                for (const rule of rulesDB) {
                    if (tx.description.toLowerCase().includes(rule.keyword.toLowerCase())) {
                        tx.type = rule.type;
                        tx.category = rule.category;
                        tx.subCategory = rule.subCategory;
                        categorized.push(tx);
                        ruleFound = true;
                        break;
                    }
                }
                if (!ruleFound) {
                    unmatched.push(tx);
                }
            });
            return { categorized, unmatched };
        }

        async function categorizeWithAI(transactions, apiKey) {
            const BATCH_SIZE = 25;
            const totalBatches = Math.ceil(transactions.length / BATCH_SIZE);
            
            for (let i = 0; i < totalBatches; i++) {
                aiStatusMessage.textContent = `Step 2/4: AI is categorizing new transactions (batch ${i + 1} of ${totalBatches})...`;
                const batch = transactions.slice(i * BATCH_SIZE, (i + 1) * BATCH_SIZE);
                const descriptions = batch.map(tx => tx.description);
                
                const schema = { type: "ARRAY", items: { type: "OBJECT", properties: { "type": { "type": "STRING" }, "category": { "type": "STRING" }, "subCategory": { "type": "STRING" } }, required: ["type", "category"] } };
                const prompt = `Analyze this list of transaction descriptions and categorize each one into a 3-tier system: Type > Category > Sub-category. If a sub-category doesn't apply, return an empty string. CRITICAL: The returned JSON array MUST have the exact same number of elements as the input 'Descriptions' array. If you cannot determine a category, you MUST return an entry with 'type' and 'category' set to 'Uncategorized'. Descriptions: ${JSON.stringify(descriptions)}`;
                
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory, generationConfig: { responseMimeType: "application/json", responseSchema: schema } };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { console.error("AI Categorization failed:", await response.text()); continue; }
                const result = await response.json();
                if (!result.candidates || !result.candidates[0].content.parts[0].text) { console.warn(`AI response for batch ${i+1} was malformed. Skipping.`); continue; }
                let aiCategoriesForBatch;
                try {
                    aiCategoriesForBatch = JSON.parse(result.candidates[0].content.parts[0].text);
                } catch (e) {
                    // Try to fix common JSON issues (e.g., trailing commas)
                    let text = result.candidates[0].content.parts[0].text;
                    text = text.replace(/,\s*([\]\}])/g, '$1'); // Remove trailing commas
                    try {
                        aiCategoriesForBatch = JSON.parse(text);
                    } catch (e2) {
                        console.warn(`AI response for batch ${i+1} could not be parsed as JSON. Skipping batch.`);
                        continue;
                    }
                }

                // --- LOGGING: Show AI output for this batch ---
                console.log(`AI response for batch ${i+1}:`, aiCategoriesForBatch);

                // Patch: Ensure output array is always the same length as input batch
                if (!Array.isArray(aiCategoriesForBatch)) {
                    console.warn(`AI response for batch ${i+1} is not an array. Skipping batch.`);
                    continue;
                }
                if (aiCategoriesForBatch.length !== batch.length) {
                    console.warn(`Mismatch in batch ${i+1}: AI returned ${aiCategoriesForBatch.length} categories for ${batch.length} transactions.`);
                }
                // Fill missing entries with Uncategorized
                for (let j = 0; j < batch.length; j++) {
                    const cats = aiCategoriesForBatch[j];
                    if (cats && cats.type && cats.category) {
                        batch[j].type = cats.type; batch[j].category = cats.category; batch[j].subCategory = cats.subCategory || '';
                    } else {
                        // If missing or invalid, set as Uncategorized
                        batch[j].type = 'Uncategorized';
                        batch[j].category = 'Uncategorized';
                        batch[j].subCategory = '';
                        if (cats !== undefined) {
                            console.warn(`AI failed to provide a valid category for item at index ${j} in batch ${i+1}. Description: "${batch[j].description}"`);
                        }
                    }
                }
            }
            return transactions;
        }

        function buildTemporaryHierarchy(categorizedTransactions) {
            const tempHierarchy = JSON.parse(JSON.stringify(categoryHierarchy)); // Deep copy
            categorizedTransactions.forEach(tx => {
                if (tx.type === 'Uncategorized') return;
                if (!tempHierarchy[tx.type]) tempHierarchy[tx.type] = {};
                if (!tempHierarchy[tx.type][tx.category]) tempHierarchy[tx.type][tx.category] = [];
                if (tx.subCategory && !tempHierarchy[tx.type][tx.category].includes(tx.subCategory)) {
                    tempHierarchy[tx.type][tx.category].push(tx.subCategory);
                }
            });
            return tempHierarchy;
        }

        async function consolidateWithAI(tempHierarchy, apiKey) {
            const prompt = `Analyze the following category hierarchy. Consolidate similar categories into a more logical structure. For example, merge 'Food > Restaurants', 'Lifestyle > Dining', and 'Food+Drink > DiningOut' into something like 'Food > Dining > Restaurant'.
            
            Current Hierarchy:
            ${JSON.stringify(tempHierarchy, null, 2)}
            
            Return ONLY a JSON object containing one key: 'mapping'.
            The value of 'mapping' should be an array that maps EVERY original category and sub-category to its new path. Each item in the array should have an 'old' and 'new' object, each with 'type', 'category', and 'subCategory' fields. It is critical that every single original category from the 'Current Hierarchy' is present in the 'old' part of the mapping. If a category is not changed, its 'old' and 'new' values should be identical.
            Ensure the entire output is a single, valid JSON object.`;

            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory, generationConfig: { responseMimeType: "application/json" } };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorBody = await response.text();
                console.error("AI Consolidation Error Response:", errorBody);
                throw new Error(`AI Consolidation API Error: ${response.status} ${response.statusText}`);
            }
            
            const result = await response.json();
            if (!result.candidates || !result.candidates[0].content.parts[0].text) {
                throw new Error('AI consolidation response was malformed or empty.');
            }
            let responseText = result.candidates[0].content.parts[0].text;
            // Patch: Try to extract and fix JSON
            let jsonString = '';
            let mapping;
            try {
                // Try to extract the first valid JSON object
                const startIndex = responseText.indexOf('{');
                const endIndex = responseText.lastIndexOf('}');
                if (startIndex === -1 || endIndex === -1) {
                    throw new Error('Could not find a valid JSON object in the AI response for consolidation.');
                }
                jsonString = responseText.substring(startIndex, endIndex + 1);
                // Remove trailing commas
                jsonString = jsonString.replace(/,\s*([\]\}])/g, '$1');
                // Check for truncated JSON (missing closing brackets)
                const openBrackets = (jsonString.match(/\[/g) || []).length;
                const closeBrackets = (jsonString.match(/\]/g) || []).length;
                const openBraces = (jsonString.match(/\{/g) || []).length;
                const closeBraces = (jsonString.match(/\}/g) || []).length;
                if (openBrackets !== closeBrackets || openBraces !== closeBraces) {
                    alert('The AI response was incomplete or cut off. Please reduce the number of categories or try again.');
                    console.error('AI consolidation JSON appears truncated. Raw response:', responseText);
                    throw new Error('Truncated JSON from AI.');
                }
                ({ mapping } = JSON.parse(jsonString));
            } catch (e) {
                alert('An error occurred while parsing the AI response for consolidation. Please try again or reduce the number of categories.');
                console.error('AI consolidation JSON parse error:', e, '\nRaw response:', responseText);
                throw e;
            }
            return mapping;
        }

        function applyConsolidation(mapping) {
            const newHierarchy = {};
            mapping.forEach(m => {
                const { type, category, subCategory } = m.new;
                if (!newHierarchy[type]) newHierarchy[type] = {};
                if (!newHierarchy[type][category]) newHierarchy[type][category] = [];
                if (subCategory && !newHierarchy[type][category].includes(subCategory)) {
                     newHierarchy[type][category].push(subCategory);
                }
            });

            transactionsDB.forEach(tx => {
                const matchedMapping = mapping.find(m => m.old.type === tx.type && m.old.category === tx.category && (m.old.subCategory || '') === (tx.subCategory || ''));
                if (matchedMapping) {
                    tx.type = matchedMapping.new.type;
                    tx.category = matchedMapping.new.category;
                    tx.subCategory = matchedMapping.new.subCategory || '';
                }
            });

            rulesDB.forEach(rule => {
                const matchedMapping = mapping.find(m => m.old.type === rule.type && m.old.category === rule.category && (m.old.subCategory || '') === (rule.subCategory || ''));
                if (matchedMapping) {
                    rule.type = matchedMapping.new.type;
                    rule.category = matchedMapping.new.category;
                    rule.subCategory = matchedMapping.new.subCategory || '';
                }
            });

            categoryHierarchy = newHierarchy;
        }

        function generateNewRules(categorizedTransactions) {
            // Optimize: Only add rules for unique keywords not already present
            const existingKeywords = new Set(rulesDB.map(r => r.keyword.toLowerCase()));
            const newRuleMap = new Map();
            for (const tx of categorizedTransactions) {
                if (tx.type === 'Uncategorized') continue;
                const keyword = extractKeyword(tx.description);
                if (!keyword) continue;
                const keyLower = keyword.toLowerCase();
                if (!existingKeywords.has(keyLower) && !newRuleMap.has(keyLower)) {
                    newRuleMap.set(keyLower, { keyword, type: tx.type, category: tx.category, subCategory: tx.subCategory || '' });
                }
            }
            for (const rule of newRuleMap.values()) {
                rulesDB.push(rule);
                existingKeywords.add(rule.keyword.toLowerCase());
            }
        }
        
        function processStandardImport(mapping) {
            importOptionsModal.classList.add('hidden');
            const { newTransactions, duplicateCount, errorCount } = parseNewTransactions(mapping);
            const { categorized, unmatched } = applyExistingRules(newTransactions);
            
            transactionsDB.push(...categorized, ...unmatched);
            newTransactions.forEach(tx => existingTransactionKeys.add(tx.id));

            saveDataToLocal();
            renderAll();
            importStatus.textContent = `Import complete! ${newTransactions.length} new txns added. ${categorized.length} matched by rules. ${duplicateCount} duplicates ignored.`;
            importStatus.className = 'text-sm font-medium text-green-600';
        }

        // --- Rendering and UI Updates ---
        function renderTransactionTable() {
            let transactionsToRender = [...transactionsDB];
            filterControls.style.display = 'block';
            transactionsTitle.textContent = "Transactions";
            if (isReviewMode) {
                transactionsTitle.textContent = "Transactions to Review";
                filterControls.style.display = 'none';
                transactionsToRender = transactionsDB.filter(tx => {
                    const hasSubcategories = categoryHierarchy[tx.type] && categoryHierarchy[tx.type][tx.category] && categoryHierarchy[tx.type][tx.category].length > 0;
                    const isUncategorized = tx.type === 'Uncategorized' || tx.category === 'Uncategorized';
                    const isMissingSubcategory = hasSubcategories && !tx.subCategory;
                    return isUncategorized || isMissingSubcategory;
                });
            } else {
                const startDate = document.getElementById('filter-start-date').value;
                const endDate = document.getElementById('filter-end-date').value;
                const type = filterTypeSelect.value;
                const category = filterCategorySelect.value;
                const subcategory = filterSubCategorySelect.value;
                const keyword = document.getElementById('filter-keyword').value.trim().toLowerCase();

                if (startDate) transactionsToRender = transactionsToRender.filter(tx => tx.date >= startDate);
                if (endDate) transactionsToRender = transactionsToRender.filter(tx => tx.date <= endDate);
                if (type) transactionsToRender = transactionsToRender.filter(tx => tx.type === type);
                if (category) transactionsToRender = transactionsToRender.filter(tx => tx.category === category);
                if (subcategory) transactionsToRender = transactionsToRender.filter(tx => tx.subCategory === subcategory);
                if (keyword) transactionsToRender = transactionsToRender.filter(tx => tx.description && tx.description.toLowerCase().includes(keyword));
            }
            
            currentlyDisplayedTransactions = transactionsToRender.sort((a, b) => new Date(b.date) - new Date(a.date));

            const totalPages = Math.ceil(currentlyDisplayedTransactions.length / transactionsPerPage);
            const startIndex = (transactionCurrentPage - 1) * transactionsPerPage;
            const endIndex = startIndex + transactionsPerPage;
            const paginatedTransactions = currentlyDisplayedTransactions.slice(startIndex, endIndex);

            if (paginatedTransactions.length === 0) {
                transactionsContainer.innerHTML = `<p class="text-gray-500 text-center p-10">${isReviewMode ? 'All transactions are categorized!' : 'No transactions match the current filters.'}</p>`;
                if (isReviewMode) { showPage('dashboard'); }
                renderPaginationControls(0, 0); // Render empty pagination
                return;
            }

            let tableHTML = `<div class="overflow-x-auto"><table class="min-w-full data-table"><thead class="border-b"><tr><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Date</th><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Description</th><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Amount</th><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Type</th><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Category</th><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Sub-category</th></tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            
            paginatedTransactions.forEach((tx) => {
                const txIndex = transactionsDB.findIndex(dbTx => dbTx.id === tx.id);
                const amountColor = tx.amount < 0 ? 'text-red-600' : 'text-green-600';
                const typeOptions = Object.keys(categoryHierarchy).map(type => `<option value="${type}" ${tx.type === type ? 'selected' : ''}>${type}</option>`).join('');
                const typeSelect = `<select class="category-select" onchange="updateType(${txIndex}, this.value)"><option value="--create-new--">-- Create New --</option><option value="Uncategorized" ${!tx.type || tx.type === 'Uncategorized' ? 'selected' : ''}>Uncategorized</option>${typeOptions}</select>`;
                
                const categoriesForType = categoryHierarchy[tx.type] || {};
                const mainCategoryOptions = Object.keys(categoriesForType).map(cat => `<option value="${cat}" ${tx.category === cat ? 'selected' : ''}>${cat}</option>`).join('');
                const mainCategorySelect = `<select class="category-select" onchange="updateCategory(${txIndex}, this.value)" ${!tx.type || tx.type === 'Uncategorized' ? 'disabled' : ''}><option value="--create-new--">-- Create New --</option><option value="Uncategorized" ${!tx.category || tx.category === 'Uncategorized' ? 'selected' : ''}>Uncategorized</option>${mainCategoryOptions}</select>`;
                
                const subCategoriesForCategory = (categoriesForType && categoriesForType[tx.category]) ? categoriesForType[tx.category] : [];
                const subCategoryOptions = subCategoriesForCategory.map(subCat => `<option value="${subCat}" ${tx.subCategory === subCat ? 'selected' : ''}>${subCat}</option>`).join('');
                const subCategorySelect = `<select class="category-select" onchange="updateSubCategory(${txIndex}, this.value)" ${!tx.type || tx.type === 'Uncategorized' || !tx.category || tx.category === 'Uncategorized' ? 'disabled' : ''}><option value="--create-new--">-- Create New --</option><option value="" ${!tx.subCategory ? 'selected' : ''}>--</option>${subCategoryOptions}</select>`;
                
                tableHTML += `<tr data-transaction-index="${txIndex}"><td class="text-sm text-gray-700 whitespace-nowrap">${tx.date}</td><td class="text-sm text-gray-700">${tx.description}</td><td class="text-sm font-medium ${amountColor} whitespace-nowrap">${formatCurrency(tx.amount)}</td><td class="text-sm text-gray-500">${typeSelect}</td><td class="text-sm text-gray-500">${mainCategorySelect}</td><td class="text-sm text-gray-500">${subCategorySelect}</td></tr>`;
            });
            tableHTML += `</tbody></table></div>`;
            transactionsContainer.innerHTML = tableHTML;
            renderPaginationControls(totalPages, currentlyDisplayedTransactions.length);
        }

        function renderPaginationControls(totalPages, totalItems) {
            if (totalPages <= 1) {
                paginationControls.innerHTML = '';
                return;
            }

            const prevDisabled = transactionCurrentPage === 1 ? 'disabled' : '';
            const nextDisabled = transactionCurrentPage === totalPages ? 'disabled' : '';
            
            paginationControls.innerHTML = `
                <button id="prev-page-btn" ${prevDisabled} class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed">Previous</button>
                <span class="font-medium text-gray-700">Page ${transactionCurrentPage} of ${totalPages}</span>
                <button id="next-page-btn" ${nextDisabled} class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed">Next</button>
            `;

            document.getElementById('prev-page-btn').addEventListener('click', () => {
                if (transactionCurrentPage > 1) {
                    transactionCurrentPage--;
                    renderTransactionTable();
                }
            });
            document.getElementById('next-page-btn').addEventListener('click', () => {
                if (transactionCurrentPage < totalPages) {
                    transactionCurrentPage++;
                    renderTransactionTable();
                }
            });
        }
        
        function promptToCreateRule(tx) {
            const keyword = extractKeyword(tx.description);
            if (!keyword) return;
            const ruleExists = rulesDB.some(r => r.keyword.toLowerCase() === keyword.toLowerCase());
            if (ruleExists) return;
            const categoryPath = `${tx.type} > ${tx.category}` + (tx.subCategory ? ` > ${tx.subCategory}` : '');
            const confirmationMessage = `Create a new rule for descriptions containing "${keyword}" to always categorize as "${categoryPath}"?`;
            setTimeout(() => {
                if (confirm(confirmationMessage)) {
                    rulesDB.push({ keyword: keyword, type: tx.type, category: tx.category, subCategory: tx.subCategory || '' });
                    renderRulesTable();
                    setCategoryStatus(`New rule created for "${keyword}"`, 'green');
                    saveDataToLocal();
                }
            }, 100);
        }

        function updateType(txIndex, value) {
            if (value === '--create-new--') {
                showNewCategoryModal(txIndex, 'type');
                return;
            }
            const tx = transactionsDB[txIndex];
            tx.type = value;
            tx.category = 'Uncategorized';
            tx.subCategory = '';
            renderTransactionTable();
            updateDashboard();
            saveDataToLocal();
        }
        
        function updateCategory(txIndex, value) {
            if (value === '--create-new--') {
                showNewCategoryModal(txIndex, 'category');
                return;
            }
            const tx = transactionsDB[txIndex];
            const originalIsUncategorized = !tx.category || tx.category === 'Uncategorized';
            tx.category = value;
            tx.subCategory = '';
            const hasSubcategories = categoryHierarchy[tx.type] && categoryHierarchy[tx.type][tx.category] && categoryHierarchy[tx.type][tx.category].length > 0;
            if (originalIsUncategorized && value !== 'Uncategorized' && !hasSubcategories) {
                promptToCreateRule(tx);
            }
            renderTransactionTable();
            updateDashboard();
            saveDataToLocal();
        }

        function updateSubCategory(txIndex, value) {
            if (value === '--create-new--') {
                showNewCategoryModal(txIndex, 'subcategory');
                return;
            }
            const tx = transactionsDB[txIndex];
            tx.subCategory = value;
            promptToCreateRule(tx);
            renderTransactionTable();
            updateDashboard();
            saveDataToLocal();
        }

        function showNewCategoryModal(txIndex, level) {
            const tx = transactionsDB[txIndex];
            modalTxIndexInput.value = txIndex;
            
            // Reset and pre-fill form
            modalNewTypeInput.value = '';
            modalNewCategoryInput.value = '';
            modalNewSubcategoryInput.value = '';
            modalNewTypeInput.disabled = false;
            modalNewCategoryInput.disabled = false;

            if (level === 'category' || level === 'subcategory') {
                modalNewTypeInput.value = tx.type !== 'Uncategorized' ? tx.type : '';
                modalNewTypeInput.disabled = true;
            }
            if (level === 'subcategory') {
                modalNewCategoryInput.value = tx.category !== 'Uncategorized' ? tx.category : '';
                modalNewCategoryInput.disabled = true;
            }
            
            modalCategoryStatus.textContent = '';
            newCategoryModal.classList.remove('hidden');
        }

        function handleSaveNewCategory() {
            const txIndex = modalTxIndexInput.value;
            const tx = transactionsDB[txIndex];
            
            const type = modalNewTypeInput.value.trim();
            const category = modalNewCategoryInput.value.trim();
            const subCategory = modalNewSubcategoryInput.value.trim();

            if (!type || !category) {
                modalCategoryStatus.textContent = "Type and Category fields are required.";
                modalCategoryStatus.className = "text-sm mt-2 text-red-600";
                return;
            }

            // Update hierarchy
            if (!categoryHierarchy[type]) categoryHierarchy[type] = {};
            if (!categoryHierarchy[type][category]) categoryHierarchy[type][category] = [];
            if (subCategory && !categoryHierarchy[type][category].includes(subCategory)) {
                categoryHierarchy[type][category].push(subCategory);
                categoryHierarchy[type][category].sort();
            }

            // Update the transaction
            tx.type = type;
            tx.category = category;
            tx.subCategory = subCategory;

            // Clean up and re-render
            newCategoryModal.classList.add('hidden');
            populateAllDropdowns();
            renderTransactionTable();
            updateDashboard();
            saveDataToLocal();

            // Prompt to create a rule
            promptToCreateRule(tx);
        }
        
        function handleRenameCategory(categoryString) {
            const parts = categoryString.split(' > ');
            const [type, category, subCategory] = parts;
            const oldName = parts[parts.length - 1];
            
            const newName = prompt(`Enter the new name for "${oldName}":`, oldName);
            if (!newName || newName.trim() === '' || newName.trim() === oldName) return;

            const trimmedNewName = newName.trim();

            if (subCategory) {
                const subCatIndex = categoryHierarchy[type][category].indexOf(subCategory);
                if (subCatIndex > -1) {
                    if (categoryHierarchy[type][category].includes(trimmedNewName)) { alert(`Sub-category "${trimmedNewName}" already exists.`); return; }
                    categoryHierarchy[type][category][subCatIndex] = trimmedNewName;
                    transactionsDB.forEach(tx => { if (tx.type === type && tx.category === category && tx.subCategory === subCategory) tx.subCategory = trimmedNewName; });
                    rulesDB.forEach(rule => { if (rule.type === type && rule.category === category && rule.subCategory === subCategory) rule.subCategory = trimmedNewName; });
                }
            } else if (category) {
                if (categoryHierarchy[type][trimmedNewName]) { alert(`Category "${trimmedNewName}" already exists in this Type.`); return; }
                categoryHierarchy[type][trimmedNewName] = categoryHierarchy[type][category];
                delete categoryHierarchy[type][category];
                transactionsDB.forEach(tx => { if (tx.type === type && tx.category === category) tx.category = trimmedNewName; });
                rulesDB.forEach(rule => { if (rule.type === type && rule.category === category) rule.category = trimmedNewName; });
            } else {
                if (categoryHierarchy[trimmedNewName]) { alert(`Type "${trimmedNewName}" already exists.`); return; }
                categoryHierarchy[trimmedNewName] = categoryHierarchy[type];
                delete categoryHierarchy[type];
                transactionsDB.forEach(tx => { if (tx.type === type) tx.type = trimmedNewName; });
                rulesDB.forEach(rule => { if (rule.type === type) rule.type = trimmedNewName; });
            }

            populateAllDropdowns();
            renderAll();
            saveDataToLocal();
        }
        
        function handleAddCategory() {
            const typeInput = document.getElementById('new-type-input');
            const categoryInput = document.getElementById('new-category-input');
            const subCategoryInput = document.getElementById('new-subcategory-input');

            const type = typeInput.value.trim();
            const category = categoryInput.value.trim();
            const subCategory = subCategoryInput.value.trim();

            if (!type || !category) {
                setCategoryStatus("Type and Category fields are required.", 'red');
                return;
            }

            if (!categoryHierarchy[type]) categoryHierarchy[type] = {};
            if (!categoryHierarchy[type][category]) categoryHierarchy[type][category] = [];

            if (subCategory && !categoryHierarchy[type][category].includes(subCategory)) {
                categoryHierarchy[type][category].push(subCategory);
                categoryHierarchy[type][category].sort();
            }

            // Clear the input fields
            typeInput.value = '';
            categoryInput.value = '';
            subCategoryInput.value = '';

            renderCategories(); 
            populateAllDropdowns();
            saveDataToLocal(); 
            setCategoryStatus("Category added successfully!", 'green');
        }

        function handleDeleteCategory(categoryString) {
            if (!confirm(`Are you sure you want to delete category: "${categoryString}"? This will remove it from the hierarchy but will not re-categorize existing transactions or rules.`)) return;
            const parts = categoryString.split(' > ');
            const [type, category, subCategory] = parts;
            if (subCategory) {
                const index = categoryHierarchy[type][category].indexOf(subCategory);
                if (index > -1) categoryHierarchy[type][category].splice(index, 1);
            } else if (category) {
                delete categoryHierarchy[type][category];
            } else {
                delete categoryHierarchy[type];
            }
            renderCategories(); 
            populateAllDropdowns(); 
            saveDataToLocal();
        }

        async function consolidateCategoriesWithAI() {
            const apiKey = getApiKey();
            if (!apiKey) {
                alert("Please add your Google AI API Key on the Settings page to use this feature.");
                showPage('settings');
                return;
            }
            if (!confirm("This will use AI to consolidate your category list. The changes will be applied to all transactions and rules. Do you want to proceed?")) {
                return;
            }

            aiProgressModal.classList.remove('hidden');
            aiStatusMessage.textContent = 'Analyzing your categories for consolidation...';
            
            const prompt = `Analyze the following category hierarchy. Consolidate similar categories into a more logical structure. For example, merge 'Food > Restaurants', 'Lifestyle > Dining', and 'Food+Drink > DiningOut' into something like 'Food > Dining > Restaurant'.
            
            Current Hierarchy:
            ${JSON.stringify(categoryHierarchy, null, 2)}
            
            Return ONLY a JSON object containing one key: 'mapping'.
            The value of 'mapping' should be an array that maps EVERY original category and sub-category to its new path. Each item in the array should have an 'old' and 'new' object, each with 'type', 'category', and 'subCategory' fields. It is critical that every single original category from the 'Current Hierarchy' is present in the 'old' part of the mapping. If a category is not changed, its 'old' and 'new' values should be identical.
            Ensure the entire output is a single, valid JSON object.`;

            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory, generationConfig: { responseMimeType: "application/json" } };
            
            try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) {
                     const errorBody = await response.text();
                     console.error("AI API Error Response:", errorBody);
                     throw new Error(`AI API Error: ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                if (!result.candidates || !result.candidates[0].content.parts[0].text) {
                    throw new Error('AI response was malformed or empty.');
                }
                let responseText = result.candidates[0].content.parts[0].text;
                // Patch: Try to extract and fix JSON
                let jsonString = '';
                let mapping;
                try {
                    const startIndex = responseText.indexOf('{');
                    const endIndex = responseText.lastIndexOf('}');
                    if (startIndex === -1 || endIndex === -1) {
                        throw new Error('Could not find a valid JSON object in the AI response for consolidation.');
                    }
                    jsonString = responseText.substring(startIndex, endIndex + 1);
                    jsonString = jsonString.replace(/,\s*([\]\}])/g, '$1');
                    // Check for truncated JSON (missing closing brackets)
                    const openBrackets = (jsonString.match(/\[/g) || []).length;
                    const closeBrackets = (jsonString.match(/\]/g) || []).length;
                    const openBraces = (jsonString.match(/\{/g) || []).length;
                    const closeBraces = (jsonString.match(/\}/g) || []).length;
                    if (openBrackets !== closeBrackets || openBraces !== closeBraces) {
                        alert('The AI response was incomplete or cut off. Please reduce the number of categories or try again.');
                        console.error('AI consolidation JSON appears truncated. Raw response:', responseText);
                        aiProgressModal.classList.add('hidden');
                        return;
                    }
                    ({ mapping } = JSON.parse(jsonString));
                } catch (e) {
                    alert('An error occurred while parsing the AI response for consolidation. Please try again or reduce the number of categories.');
                    console.error('AI consolidation JSON parse error:', e, '\nRaw response:', responseText);
                    aiProgressModal.classList.add('hidden');
                    return;
                }

                aiStatusMessage.textContent = 'Applying new categories...';
                
                // Build new hierarchy from the mapping
                const newHierarchy = {};
                mapping.forEach(m => {
                    const { type, category, subCategory } = m.new;
                    if (!newHierarchy[type]) newHierarchy[type] = {};
                    if (!newHierarchy[type][category]) newHierarchy[type][category] = [];
                    if (subCategory && !newHierarchy[type][category].includes(subCategory)) {
                         newHierarchy[type][category].push(subCategory);
                    }
                });
                
                // Apply the mapping to transactions and rules
                transactionsDB.forEach(tx => {
                    const matchedMapping = mapping.find(m => 
                        m.old.type === tx.type && 
                        m.old.category === tx.category && 
                        (m.old.subCategory || '') === (tx.subCategory || '')
                    );
                    if (matchedMapping) {
                        tx.type = matchedMapping.new.type;
                        tx.category = matchedMapping.new.category;
                        tx.subCategory = matchedMapping.new.subCategory || '';
                    }
                });

                rulesDB.forEach(rule => {
                    const matchedMapping = mapping.find(m => 
                        m.old.type === rule.type && 
                        m.old.category === rule.category && 
                        (m.old.subCategory || '') === (rule.subCategory || '')
                    );
                    if (matchedMapping) {
                        rule.type = matchedMapping.new.type;
                        rule.category = matchedMapping.new.category;
                        rule.subCategory = matchedMapping.new.subCategory || '';
                    }
                });
                
                // Replace the old hierarchy
                categoryHierarchy = newHierarchy;

                saveDataToLocal();
                renderAll();
                setCategoryStatus("Categories consolidated successfully!", "green");

            } catch (e) {
                console.error("Category consolidation failed:", e);
                alert(`An error occurred during AI consolidation: ${e.message}. Please check the console.`);
            } finally {
                aiProgressModal.classList.add('hidden');
            }
        }

        function renderCategories() {
            let totalCategories = 0;
            Object.keys(categoryHierarchy).forEach(type => {
                totalCategories++; // count type
                const categories = Object.keys(categoryHierarchy[type]);
                totalCategories += categories.length; // count categories
                categories.forEach(category => {
                    if (Array.isArray(categoryHierarchy[type][category])) {
                        totalCategories += categoryHierarchy[type][category].length; // count sub-categories
                    }
                });
            });
            categoriesCount.textContent = `(${totalCategories} total)`;

            if (Object.keys(categoryHierarchy).length === 0) { 
                categoriesListContainer.innerHTML = '<p class="text-gray-500 text-center">No categories defined.</p>'; 
                return; 
            }
            let html = '<ul class="space-y-2">';
            Object.keys(categoryHierarchy).sort().forEach(type => {
                html += `<li class="p-2 rounded-lg bg-gray-100 font-bold text-gray-800 flex justify-between items-center">
                        <span>${type}</span>
                        <span class="flex items-center">
                            <button onclick="handleRenameCategory('${type}')" title="Rename" class="icon-btn text-gray-500 hover:text-blue-600 mr-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path></svg></button>
                            <button onclick="handleDeleteCategory('${type}')" title="Delete" class="icon-btn text-gray-500 hover:text-red-600 text-xl leading-none">&times;</button>
                        </span>
                     </li>`;
                Object.keys(categoryHierarchy[type]).sort().forEach(category => {
                    html += `<li class="ml-4 p-2 rounded-lg bg-gray-50 flex justify-between items-center">
                            <span>${category}</span>
                            <span class="flex items-center">
                                <button onclick="handleRenameCategory('${type} > ${category}')" title="Rename" class="icon-btn text-gray-500 hover:text-blue-600 mr-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path></svg></button>
                                <button onclick="handleDeleteCategory('${type} > ${category}')" title="Delete" class="icon-btn text-gray-500 hover:text-red-600 text-xl leading-none">&times;</button>
                            </span>
                         </li>`;
                    if (categoryHierarchy[type][category] && categoryHierarchy[type][category].length > 0) {
                        html += '<ul class="ml-8 space-y-1 mt-1">';
                        categoryHierarchy[type][category].forEach(sub => {
                            html += `<li class="p-1 flex justify-between items-center">
                                    <span>${sub}</span>
                                    <span class="flex items-center">
                                        <button onclick="handleRenameCategory('${type} > ${category} > ${sub}')" title="Rename" class="icon-btn text-gray-500 hover:text-blue-600 mr-2"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path></svg></button>
                                        <button onclick="handleDeleteCategory('${type} > ${category} > ${sub}')" title="Delete" class="icon-btn text-gray-500 hover:text-red-600 text-xl leading-none">&times;</button>
                                    </span>
                                 </li>`;
                        });
                        html += '</ul>';
                    }
                });
            });
            html += '</ul>'; categoriesListContainer.innerHTML = html;
        }

        function updateDashboard() {
            const currentYear = new Date().getFullYear().toString();
            const yearlySpend = transactionsDB.filter(tx => tx.amount < 0 && tx.date && tx.date.startsWith(currentYear)).reduce((total, tx) => total + tx.amount, 0);
            totalSpendEl.textContent = formatCurrency(yearlySpend);
            const uncategorizedCount = transactionsDB.filter(tx => !tx.type || tx.type === 'Uncategorized' || !tx.category || tx.category === 'Uncategorized').length;
            reviewCountEl.textContent = uncategorizedCount;
            reviewCardLabel.style.display = uncategorizedCount > 0 ? 'inline-flex' : 'none';
            const spendingByCategory = {};
            transactionsDB.filter(tx => tx.amount < 0 && tx.type !== 'Uncategorized' && tx.category !== 'Uncategorized').forEach(tx => {
                const key = `${tx.type} > ${tx.category}`; if (!spendingByCategory[key]) spendingByCategory[key] = 0; spendingByCategory[key] += Math.abs(tx.amount);
            });
            const topCategory = Object.keys(spendingByCategory).reduce((a, b) => spendingByCategory[a] > spendingByCategory[b] ? a : b, null);
            topCategoryEl.textContent = topCategory || 'N/A';
            renderDashboardChart();
        }
        
        function populateAllDropdowns() {
            populateFilterDropdowns();
            populateRuleDropdowns();
            populateReportFilterDropdowns();
            populateDashboardFilterDropdowns();
        }

        function populateFilterDropdowns(level = 'all', ids = {type: 'filter-type', cat: 'filter-category', sub: 'filter-subcategory'}) {
            const typeSelect = document.getElementById(ids.type);
            const catSelect = document.getElementById(ids.cat);
            const subCatSelect = document.getElementById(ids.sub);

            const currentType = typeSelect.value;
            const currentCategory = catSelect.value;
            const currentSubCategory = subCatSelect ? subCatSelect.value : '';

            if (level === 'all' || level === 'type') {
                const types = Object.keys(categoryHierarchy).sort((a,b) => a.localeCompare(b));
                typeSelect.innerHTML = `<option value="">All Types</option>` + types.map(t => `<option value="${t}">${t}</option>`).join('');
                if (level !== 'all') typeSelect.value = currentType;
            }
            
            const selectedType = typeSelect.value;
            if (level === 'all' || level === 'type' || level === 'category') {
                catSelect.innerHTML = `<option value="">All Categories</option>`;
                if (selectedType && categoryHierarchy[selectedType]) {
                    const categories = Object.keys(categoryHierarchy[selectedType]).sort((a,b) => a.localeCompare(b));
                    catSelect.innerHTML += categories.map(c => `<option value="${c}">${c}</option>`).join('');
                    catSelect.disabled = false;
                } else {
                    catSelect.disabled = true;
                }
                if (level !== 'all' && level !=='type') catSelect.value = currentCategory;
            }

            const selectedCategory = catSelect.value;
            if (subCatSelect) {
                subCatSelect.innerHTML = `<option value="">All Sub-categories</option>`;
                if (selectedType && selectedCategory && categoryHierarchy[selectedType][selectedCategory]) {
                    const subcategories = categoryHierarchy[selectedType][selectedCategory].sort((a,b) => a.localeCompare(b));
                    subCatSelect.innerHTML += subcategories.map(s => `<option value="${s}">${s}</option>`).join('');
                    subCatSelect.disabled = false;
                } else {
                    subCatSelect.disabled = true;
                }
                 if (level !== 'all' && level !=='type' && level !== 'category') subCatSelect.value = currentSubCategory;
            }
        }
        
        function populateRuleDropdowns(level = 'all') {
            populateFilterDropdowns(level, {type: 'rule-type', cat: 'rule-category', sub: 'rule-subcategory'});
        }

        function populateReportFilterDropdowns(level='all') {
             populateFilterDropdowns(level, {type: 'report-filter-type', cat: 'report-filter-category', sub: 'report-filter-subcategory'});
        }
        
        function populateDashboardFilterDropdowns(level='all') {
             populateFilterDropdowns(level, {type: 'dashboard-filter-type', cat: 'dashboard-filter-category', sub: 'dashboard-filter-subcategory'});
        }

        function handleAddRule() {
            const keyword = ruleKeywordInput.value.trim(); const type = ruleTypeSelect.value; const category = ruleCategorySelect.value; const subCategory = ruleSubcategorySelect.value;
            if (!keyword || !type || !category) { alert("Please provide a keyword, type, and category."); return; }
            const ruleExists = rulesDB.some(r => r.keyword.toLowerCase() === keyword.toLowerCase());
            if (ruleExists) { alert(`A rule for the keyword "${keyword}" already exists.`); return; }
            rulesDB.push({ keyword, type, category, subCategory }); ruleKeywordInput.value = '';
            populateRuleDropdowns('all'); renderRulesTable(); saveDataToLocal();
        }

        function handleDeleteRule(index) { rulesDB.splice(index, 1); renderRulesTable(); saveDataToLocal(); }

        function renderRulesTable() {
            const filters = getRuleFilterValues();
            let filteredRules = rulesDB.filter(r => {
                if (filters.type && r.type !== filters.type) return false;
                if (filters.category && r.category !== filters.category) return false;
                if (filters.subCategory && (r.subCategory || '') !== filters.subCategory) return false;
                if (filters.keyword && !r.keyword.toLowerCase().includes(filters.keyword)) return false;
                return true;
            });
            rulesCount.textContent = `(${filteredRules.length} total)`;
            if (filteredRules.length === 0) {
                rulesListContainer.innerHTML = `<p class="text-gray-500 text-center p-10">No rules match the current filters.</p>`;
                return;
            }
            let tableHTML = `<table class="min-w-full data-table"><thead class="border-b"><tr><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Keyword</th><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider">Categorization</th><th class="font-semibold text-sm text-gray-600 uppercase tracking-wider"></th></tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
            filteredRules.sort((a,b) => a.keyword.localeCompare(b.keyword));
            filteredRules.forEach((rule, index) => {
                const fullCategory = `${rule.type} > ${rule.category}` + (rule.subCategory ? ` > ${rule.subCategory}`: '');
                // Find the rule's index in rulesDB for delete/edit
                const ruleIdx = rulesDB.findIndex(r => r.keyword === rule.keyword && r.type === rule.type && r.category === rule.category && r.subCategory === rule.subCategory);
                tableHTML += `<tr><td class="text-sm font-medium text-gray-900">${rule.keyword}</td><td class="text-sm text-gray-500">${fullCategory}</td><td class="text-right flex gap-2 justify-end"><button onclick="handleEditRule(${ruleIdx})" class="text-blue-500 hover:text-blue-700 mr-2" title="Edit"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path></svg></button><button onclick="handleDeleteRule(${ruleIdx})" class="text-red-500 hover:text-red-700" title="Delete"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button></td></tr>`;
            });
            tableHTML += `</tbody></table>`;
            rulesListContainer.innerHTML = tableHTML;
        }
        
        function generateReport() {
            const startDate = document.getElementById('report-start-date').value;
            const endDate = document.getElementById('report-end-date').value;
            const typeFilter = reportFilterType.value;
            const categoryFilter = reportFilterCategory.value;
            const subCategoryFilter = reportFilterSubcategory.value;

            if (!startDate || !endDate) { alert('Please select a start and end date.'); return; }
            
            let filteredTx = transactionsDB.filter(tx => tx.amount < 0 && tx.date >= startDate && tx.date <= endDate);
            if (typeFilter) filteredTx = filteredTx.filter(tx => tx.type === typeFilter);
            if (categoryFilter) filteredTx = filteredTx.filter(tx => tx.category === categoryFilter);
            if (subCategoryFilter) filteredTx = filteredTx.filter(tx => tx.subCategory === subCategoryFilter);

            if (filteredTx.length === 0) {
                reportOutput.innerHTML = `<p class="text-gray-500 text-center p-10">No spending transactions found for the selected filters.</p>`;
                exportExcelBtn.classList.add('hidden');
                return;
            }

            const monthColumns = [...new Set(filteredTx.map(tx => tx.date.substring(0, 7)))].sort();
            const pivotData = {};

            filteredTx.forEach(tx => {
                const month = tx.date.substring(0, 7);
                const type = tx.type || 'Uncategorized';
                const category = tx.category || 'Uncategorized';
                const subCategory = tx.subCategory || 'N/A';
                const amount = Math.abs(tx.amount);

                if (!pivotData[type]) pivotData[type] = {};
                if (!pivotData[type][category]) pivotData[type][category] = {};
                if (!pivotData[type][category][subCategory]) {
                    pivotData[type][category][subCategory] = monthColumns.reduce((acc, m) => ({...acc, [m]: 0}), {});
                }
                pivotData[type][category][subCategory][month] += amount;
            });

            renderPivotTable(pivotData, monthColumns);
            exportExcelBtn.classList.remove('hidden');
        }

        function renderPivotTable(pivotData, monthColumns) {
            const monthNames = monthColumns.map(m => new Date(m + '-02').toLocaleString('default', { month: 'short' }) + ' ' + m.substring(2,4) );
            let tableHTML = `<table class="min-w-full data-table pivot-table"><thead><tr>
                <th class="font-semibold text-sm text-gray-600 uppercase tracking-wider text-left">Category</th>
                ${monthNames.map(name => `<th class="font-semibold text-sm text-gray-600 uppercase tracking-wider text-right">${name}</th>`).join('')}
                <th class="font-semibold text-sm text-gray-600 uppercase tracking-wider text-right">Total</th>
            </tr></thead><tbody>`;

            lastReportData = { headers: ['Category', ...monthNames, 'Total'], rows: [] };
            const grandTotals = monthColumns.reduce((acc, m) => ({...acc, [m]: 0}), { total: 0 });

            Object.keys(pivotData).sort().forEach(type => {
                const typeTotals = monthColumns.reduce((acc, m) => ({...acc, [m]: 0}), { total: 0 });
                let typeBody = '';
                let typeRowsForExport = [];

                Object.keys(pivotData[type]).sort().forEach(categoryName => {
                    const catData = pivotData[type][categoryName];
                    const catTotals = monthColumns.reduce((acc, m) => ({...acc, [m]: 0}), { total: 0 });
                    let catBody = '';
                    let catRowsForExport = [];
                    
                    Object.keys(catData).sort().forEach(subCategoryName => {
                        const subCatMonthlyData = catData[subCategoryName];
                        let subCatTotal = 0;
                        monthColumns.forEach(month => {
                            const value = subCatMonthlyData[month] || 0;
                            subCatTotal += value;
                            catTotals[month] += value;
                        });
                        
                        if (subCategoryName !== 'N/A') {
                            let subCatRow = `<tr class="report-row sub-category-row hidden" data-parent-type="${type}" data-parent-cat="${type}-${categoryName}">
                                <td class="text-gray-700">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${subCategoryName}</td>`;
                            monthColumns.forEach(m => subCatRow += `<td class="text-right drillable text-red-600" onclick="drillDown('${type.replace(/'/g, "\\'")}', '${categoryName.replace(/'/g, "\\'")}', '${subCategoryName.replace(/'/g, "\\'")}', '${m}', event)">${formatCurrency(subCatMonthlyData[m] || 0)}</td>`);
                            subCatRow += `<td class="text-right drillable text-red-600" onclick="drillDown('${type.replace(/'/g, "\\'")}', '${categoryName.replace(/'/g, "\\'")}', '${subCategoryName.replace(/'/g, "\\'")}', '', event)">${formatCurrency(subCatTotal)}</td></tr>`;
                            catBody += subCatRow;

                            const exportRow = { Category: `        ${subCategoryName}` };
                            monthColumns.forEach((m, i) => exportRow[monthNames[i]] = (subCatMonthlyData[m] || 0));
                            exportRow['Total'] = subCatTotal;
                            catRowsForExport.push(exportRow);
                        }
                    });

                    catTotals.total = Object.values(catTotals).reduce((sum, val) => sum + val, 0) - catTotals.total;
                    monthColumns.forEach(m => typeTotals[m] += catTotals[m]);
                    
                    let catRow = `<tr class="report-row category-row hidden" data-parent-type="${type}" data-cat-id="${type}-${categoryName}" onclick="toggleRowGroup(this, 'cat')">
                        <td class="font-semibold">&nbsp;&nbsp;&nbsp;&nbsp;<span class="toggle-icon">▶</span>${categoryName}</td>`;
                    monthColumns.forEach(m => catRow += `<td class="font-semibold text-right drillable text-red-600" onclick="drillDown('${type.replace(/'/g, "\\'")}', '${categoryName.replace(/'/g, "\\'")}', '', '${m}', event)">${formatCurrency(catTotals[m])}</td>`);
                    catRow += `<td class="font-semibold text-right drillable text-red-600" onclick="drillDown('${type.replace(/'/g, "\\'")}', '${categoryName.replace(/'/g, "\\'")}', '', '', event)">${formatCurrency(catTotals.total)}</td></tr>`;
                    
                    typeBody += catRow + catBody;
                    
                    const catExportRow = { Category: `    ${categoryName}` };
                    monthColumns.forEach((m, i) => catExportRow[monthNames[i]] = catTotals[m]);
                    catExportRow['Total'] = catTotals.total;
                    typeRowsForExport.push(catExportRow, ...catRowsForExport);
                });
                
                typeTotals.total = Object.values(typeTotals).reduce((sum, val) => sum + val, 0) - typeTotals.total;
                let typeRow = `<tr class="report-row type-row" data-type-id="${type}" onclick="toggleRowGroup(this, 'type')">
                    <td class="font-bold"><span class="toggle-icon">▶</span>${type}</td>`;
                monthColumns.forEach(m => {
                    typeRow += `<td class="font-bold text-right drillable text-red-600" onclick="drillDown('${type.replace(/'/g, "\\'")}', '', '', '${m}', event)">${formatCurrency(typeTotals[m])}</td>`;
                    grandTotals[m] += typeTotals[m];
                });
                typeRow += `<td class="font-bold text-right drillable text-red-600" onclick="drillDown('${type.replace(/'/g, "\\'")}', '', '', '', event)">${formatCurrency(typeTotals.total)}</td></tr>`;
                
                tableHTML += typeRow + typeBody;

                const typeExportRow = { Category: type };
                monthColumns.forEach((m, i) => typeExportRow[monthNames[i]] = typeTotals[m]);
                typeExportRow['Total'] = typeTotals.total;
                lastReportData.rows.push(typeExportRow, ...typeRowsForExport);
            });

            grandTotals.total = Object.values(grandTotals).reduce((sum, val) => sum + val, 0) - grandTotals.total;
            tableHTML += '</tbody><tfoot><tr class="bg-gray-200 font-bold"><td class="p-3">Grand Total</td>';
            monthColumns.forEach(m => tableHTML += `<td class="p-3 text-right text-red-600">${formatCurrency(grandTotals[m])}</td>`);
            tableHTML += `<td class="p-3 text-right text-red-600">${formatCurrency(grandTotals.total)}</td></tr></tfoot></table>`;
            
            const grandTotalExportRow = { Category: 'Grand Total' };
            monthColumns.forEach((m, i) => grandTotalExportRow[monthNames[i]] = grandTotals[m]);
            grandTotalExportRow['Total'] = grandTotals.total;
            lastReportData.rows.push(grandTotalExportRow);
            
            reportOutput.innerHTML = tableHTML;
            setupTopScrollbar();
        }

        function toggleRowGroup(element, level) {
            const icon = element.querySelector('.toggle-icon');
            icon.classList.toggle('expanded');
            const isExpanded = icon.classList.contains('expanded');
            
            if (level === 'type') {
                const typeId = element.dataset.typeId;
                document.querySelectorAll(`.report-row.category-row[data-parent-type='${typeId}']`).forEach(row => {
                    row.classList.toggle('hidden', !isExpanded);
                    if (!isExpanded) {
                        row.querySelector('.toggle-icon')?.classList.remove('expanded');
                        const catId = row.dataset.catId;
                        document.querySelectorAll(`.report-row.sub-category-row[data-parent-cat='${catId}']`).forEach(subRow => subRow.classList.add('hidden'));
                    }
                });
            } else if (level === 'cat') {
                const catId = element.dataset.catId;
                document.querySelectorAll(`.report-row.sub-category-row[data-parent-cat='${catId}']`).forEach(row => {
                    row.classList.toggle('hidden', !isExpanded);
                });
            }
        }

        function setupTopScrollbar() {
            const topScroll = document.getElementById('top-scrollbar-container');
            const mainScroll = document.getElementById('report-output');
            const content = document.getElementById('top-scrollbar-content');
            if (mainScroll && topScroll && content) {
                content.style.width = mainScroll.scrollWidth + 'px';
                let isSyncing = false;
                topScroll.onscroll = () => {
                    if (isSyncing) return;
                    isSyncing = true;
                    mainScroll.scrollLeft = topScroll.scrollLeft;
                    isSyncing = false;
                };
                mainScroll.onscroll = () => {
                    if (isSyncing) return;
                    isSyncing = true;
                    topScroll.scrollLeft = mainScroll.scrollLeft;
                    isSyncing = false;
                };
            }
        }
        
        function drillDown(type, category, subCategory, month, event) {
            if (event) event.stopPropagation();
            
            let drillDownStartDate = document.getElementById('report-start-date').value;
            let drillDownEndDate = document.getElementById('report-end-date').value;

            if (month) {
                const year = month.substring(0,4);
                const monthNum = parseInt(month.substring(5,7), 10);
                drillDownStartDate = `${year}-${String(monthNum).padStart(2, '0')}-01`;
                const lastDay = new Date(year, monthNum, 0).getDate();
                drillDownEndDate = `${year}-${String(monthNum).padStart(2, '0')}-${lastDay}`;
            }

            document.getElementById('filter-start-date').value = drillDownStartDate;
            document.getElementById('filter-end-date').value = drillDownEndDate;

            populateFilterDropdowns('all');
            document.getElementById('filter-type').value = type === 'Uncategorized' ? '' : type;
            populateFilterDropdowns('category');
            document.getElementById('filter-category').value = category;
            populateFilterDropdowns('subcategory');
            document.getElementById('filter-subcategory').value = subCategory;
            
            showPage('transactions');
        }

        function exportReportToExcel() {
            if (!lastReportData || lastReportData.rows.length === 0) {
                alert("No report data to export. Please generate a report first.");
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            const filename = `FinTrack_Report_${today}.xlsx`;

            const dataForSheet = lastReportData.rows.map(row => {
                const newRow = {};
                for (const header of lastReportData.headers) {
                    newRow[header] = row[header];
                }
                return newRow;
            });

            const ws = XLSX.utils.json_to_sheet(dataForSheet, { header: lastReportData.headers });

            const currencyFormat = '$#,##0.00';
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = range.s.r; R <= range.e.r; ++R) { 
                for (let C = range.s.c + 1; C <= range.e.c; ++C) { 
                    const cell_address = { c: C, r: R };
                    const cell_ref = XLSX.utils.encode_cell(cell_address);
                    if (ws[cell_ref] && typeof ws[cell_ref].v === 'number') {
                       ws[cell_ref].z = currencyFormat;
                    }
                }
            }
            
            const colWidths = lastReportData.headers.map(header => ({
                wch: Math.max(header.length, ...dataForSheet.map(row => row[header]?.toString().length || 0)) + 2
            }));
            ws['!cols'] = colWidths;

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Spending Report");

            XLSX.writeFile(wb, filename);
        }

        function setCategoryStatus(message, color) {
            const colorClasses = { red: 'text-red-600', green: 'text-green-600', yellow: 'text-yellow-600' };
            categoryStatus.textContent = message; categoryStatus.className = `text-sm mt-2 ${colorClasses[color] || 'text-gray-600'}`;
            setTimeout(() => { categoryStatus.textContent = '' }, 4000);
        }

        function renderDashboardChart() {
            const type = dashboardFilterType.value;
            const category = dashboardFilterCategory.value;
            const subcategory = dashboardFilterSubcategory.value;
            const compareYear = compareYearCheckbox.checked;

            const today = new Date();
            const currentYear = today.getFullYear();
            const lastMonth = today.getMonth(); // 0-indexed

            const monthLabels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].slice(0, lastMonth + 1);

            const getMonthlyData = (year) => {
                let filteredTx = transactionsDB.filter(tx => {
                    const txYear = parseInt(tx.date.substring(0, 4));
                    return tx.amount < 0 && txYear === year;
                });

                if (type) filteredTx = filteredTx.filter(tx => tx.type === type);
                if (category) filteredTx = filteredTx.filter(tx => tx.category === category);
                if (subcategory) filteredTx = filteredTx.filter(tx => tx.subCategory === subcategory);

                const monthlyTotals = Array(lastMonth + 1).fill(0);
                filteredTx.forEach(tx => {
                    const txMonth = parseInt(tx.date.substring(5, 7)) - 1;
                    if (txMonth <= lastMonth) {
                        monthlyTotals[txMonth] += Math.abs(tx.amount);
                    }
                });
                return monthlyTotals;
            };

            const currentYearData = getMonthlyData(currentYear);
            
            const datasets = [{
                label: `${currentYear} Spending`,
                data: currentYearData,
                borderColor: '#1976D2',
                backgroundColor: 'rgba(25, 118, 210, 0.1)',
                fill: true,
                tension: 0.1
            }];

            if (compareYear) {
                const previousYearData = getMonthlyData(currentYear - 1);
                datasets.push({
                    label: `${currentYear - 1} Spending`,
                    data: previousYearData,
                    borderColor: '#90CAF9',
                    backgroundColor: 'rgba(144, 202, 249, 0.1)',
                    fill: true,
                    tension: 0.1,
                    borderDash: [5, 5]
                });
            }
            
            const ctx = document.getElementById('monthly-spending-chart').getContext('2d');
            if (monthlySpendingChart) {
                monthlySpendingChart.destroy();
            }
            monthlySpendingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: monthLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) { return '$' + value; }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
        }
        
        function renderAll() {
            updateDashboard();
            
            const currentPage = document.querySelector('.page[style*="block"]');
            if (!currentPage) return;
            
            const currentPageId = currentPage.id;
            if (currentPageId === 'dashboard-page') {
                renderDashboardChart();
            } else if (currentPageId === 'transactions-page') {
                transactionCurrentPage = 1;
                renderTransactionTable();
            } else if (currentPageId === 'categories-page') {
                renderCategories();
            } else if (currentPageId === 'rules-page') {
                renderRulesTable();
            }
        }

        function showPage(pageId, inReviewMode = false) {
            isReviewMode = inReviewMode;
            document.querySelectorAll('.page').forEach(page => page.style.display = 'none');
            const targetPage = document.getElementById(pageId + '-page');
            if (targetPage) targetPage.style.display = 'block';
            
            if (pageId !== 'transactions') { 
                isReviewMode = false;
            }
            
            renderAll(); 

            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active', 'bg-blue-100', 'text-gray-700');
                link.classList.add('text-gray-600', 'hover:bg-gray-200');
                if (link.getAttribute('onclick').includes(`'${pageId}'`)) {
                    link.classList.add('active', 'bg-blue-100', 'text-gray-700');
                    link.classList.remove('text-gray-600', 'hover:bg-gray-200');
                }
            });
        }

        function exportCategoriesAsCSV() {
            let rows = [['Type', 'Category', 'SubCategory']];
            for (const type in categoryHierarchy) {
                for (const category in categoryHierarchy[type]) {
                    if (categoryHierarchy[type][category].length === 0) {
                        rows.push([type, category, '']);
                    } else {
                        for (const sub of categoryHierarchy[type][category]) {
                            rows.push([type, category, sub]);
                        }
                    }
                }
            }
            const csvContent = rows.map(r => r.map(x => '"' + (x || '') + '"').join(',')).join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'FinTrack_Categories.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportCategoriesAsJSON() {
            const jsonStr = JSON.stringify(categoryHierarchy, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'FinTrack_Categories.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleImportCategoriesCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const lines = text.split(/\r?\n/).filter(l => l.trim());
                if (lines.length < 2) {
                    setCategoryStatus('CSV file is empty or invalid.', 'red');
                    return;
                }
                const [header, ...data] = lines;
                const cols = header.split(',').map(h => h.replace(/"/g, '').trim().toLowerCase());
                const typeIdx = cols.indexOf('type');
                const catIdx = cols.indexOf('category');
                const subIdx = cols.indexOf('subcategory');
                if (typeIdx === -1 || catIdx === -1 || subIdx === -1) {
                    setCategoryStatus('CSV must have Type, Category, and SubCategory columns.', 'red');
                    return;
                }
                const newHierarchy = {};
                data.forEach(row => {
                    const vals = row.split(',').map(x => x.replace(/"/g, '').trim());
                    const type = vals[typeIdx];
                    const category = vals[catIdx];
                    const sub = vals[subIdx];
                    if (!type || !category) return;
                    if (!newHierarchy[type]) newHierarchy[type] = {};
                    if (!newHierarchy[type][category]) newHierarchy[type][category] = [];
                    if (sub && !newHierarchy[type][category].includes(sub)) newHierarchy[type][category].push(sub);
                });
                categoryHierarchy = newHierarchy;
                saveDataToLocal();
                populateAllDropdowns();
                renderCategories();
                setCategoryStatus('Categories imported successfully!', 'green');
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        function handleImportCategoryMappingJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const mappingObj = JSON.parse(e.target.result);
                    if (!mappingObj || !Array.isArray(mappingObj.mapping)) {
                        setCategoryStatus('Invalid mapping JSON: missing mapping array.', 'red');
                        return;
                    }
                    // 1. Update transactions
                    transactionsDB.forEach(tx => {
                        const match = mappingObj.mapping.find(m =>
                            m.old.type === tx.type &&
                            m.old.category === tx.category &&
                            (m.old.subCategory || '') === (tx.subCategory || '')
                        );
                        if (match) {
                            tx.type = match.new.type;
                            tx.category = match.new.category;
                            tx.subCategory = match.new.subCategory || '';
                        }
                    });
                    // 2. Update rules: update if mapping exists, else log warning
                    let unmappedRules = [];
                    rulesDB.forEach(rule => {
                        const match = mappingObj.mapping.find(m =>
                            m.old.type === rule.type &&
                            m.old.category === rule.category &&
                            (m.old.subCategory || '') === (rule.subCategory || '')
                        );
                        if (match) {
                            rule.type = match.new.type;
                            rule.category = match.new.category;
                            rule.subCategory = match.new.subCategory || '';
                        } else {
                            unmappedRules.push({
                                keyword: rule.keyword,
                                type: rule.type,
                                category: rule.category,
                                subCategory: rule.subCategory || ''
                            });
                        }
                    });
                    // 3. Build new categoryHierarchy from mapping
                    const newHierarchy = {};
                    mappingObj.mapping.forEach(m => {
                        const { type, category, subCategory } = m.new;
                        if (!newHierarchy[type]) newHierarchy[type] = {};
                        if (!newHierarchy[type][category]) newHierarchy[type][category] = [];
                        if (subCategory && !newHierarchy[type][category].includes(subCategory)) {
                            newHierarchy[type][category].push(subCategory);
                        }
                    });
                    categoryHierarchy = newHierarchy;
                    // 4. Re-apply ALL rules to ALL transactions to ensure proper categorization
                    let reCategorizedCount = 0;
                    let improvedCount = 0;
                    transactionsDB.forEach(tx => {
                        const originalType = tx.type;
                        const originalCategory = tx.category;
                        const originalSubCategory = tx.subCategory;
                        // Find the best matching rule (most specific/longest keyword)
                        let bestRule = null;
                        let bestMatchLength = 0;
                        for (const rule of rulesDB) {
                            if (tx.description.toLowerCase().includes(rule.keyword.toLowerCase())) {
                                if (rule.keyword.length > bestMatchLength) {
                                    bestRule = rule;
                                    bestMatchLength = rule.keyword.length;
                                }
                            }
                        }
                        // Apply the best matching rule if found (always apply if a rule matches)
                        if (bestRule) {
                            tx.type = bestRule.type;
                            tx.category = bestRule.category;
                            tx.subCategory = bestRule.subCategory || '';
                            // Check if this improved the categorization
                            const wasUncategorized = originalType === 'Uncategorized' || originalCategory === 'Uncategorized' || !originalType || !originalCategory;
                            if (wasUncategorized && tx.type !== 'Uncategorized') {
                                improvedCount++;
                            }
                        }
                        // Check if categorization changed
                        if (originalType !== tx.type || originalCategory !== tx.category || originalSubCategory !== tx.subCategory) {
                            reCategorizedCount++;
                        }
                    });
                    saveDataToLocal();
                    populateAllDropdowns();
                    renderCategories();
                    let statusMsg = 'Category mapping applied successfully!';
                    if (reCategorizedCount > 0) statusMsg += ` Updated ${reCategorizedCount} transactions.`;
                    if (improvedCount > 0) statusMsg += ` Improved categorization for ${improvedCount} transactions.`;
                    if (unmappedRules.length > 0) statusMsg += ` ${unmappedRules.length} rules could not be mapped and still use old categories.`;
                    setCategoryStatus(statusMsg, unmappedRules.length > 0 ? 'yellow' : 'green');
                    if (unmappedRules.length > 0) {
                        console.warn('Unmapped rules after category mapping import:', unmappedRules);
                    }
                } catch (err) {
                    setCategoryStatus('Error parsing mapping JSON. See console.', 'red');
                    console.error('Error parsing mapping JSON:', err);
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        // Add this function to handle editing rules
        function handleEditRule(index) {
            const rule = rulesDB[index];
            if (!rule) return;
            // Pre-fill the add rule form with the rule's data
            ruleKeywordInput.value = rule.keyword;
            ruleTypeSelect.value = rule.type;
            populateRuleDropdowns('category');
            ruleCategorySelect.value = rule.category;
            populateRuleDropdowns('subcategory');
            ruleSubcategorySelect.value = rule.subCategory || '';
            // Remove the old rule (will be re-added on save)
            rulesDB.splice(index, 1);
            renderRulesTable();
            saveDataToLocal();
        }

        function populateRuleFilters() {
          // Populate Type
          const types = Array.from(new Set(rulesDB.map(r => r.type))).sort();
          ruleFilterTypeEl.innerHTML = '<option value="">All Types</option>' + types.map(t => `<option value="${t}">${t}</option>`).join('');
          // Populate Category
          const selectedType = ruleFilterTypeEl.value;
          let categories = [];
          if (selectedType) {
            categories = Array.from(new Set(rulesDB.filter(r => r.type === selectedType).map(r => r.category))).sort();
          } else {
            categories = Array.from(new Set(rulesDB.map(r => r.category))).sort();
          }
          ruleFilterCategoryEl.innerHTML = '<option value="">All Categories</option>' + categories.map(c => `<option value="${c}">${c}</option>`).join('');
          // Populate SubCategory
          const selectedCategory = ruleFilterCategoryEl.value;
          let subcategories = [];
          if (selectedType && selectedCategory) {
            subcategories = Array.from(new Set(rulesDB.filter(r => r.type === selectedType && r.category === selectedCategory).map(r => r.subCategory || ''))).sort();
          } else if (selectedCategory) {
            subcategories = Array.from(new Set(rulesDB.filter(r => r.category === selectedCategory).map(r => r.subCategory || ''))).sort();
          } else {
            subcategories = Array.from(new Set(rulesDB.map(r => r.subCategory || ''))).sort();
          }
          ruleFilterSubCategoryEl.innerHTML = '<option value="">All SubCategories</option>' + subcategories.map(s => `<option value="${s}">${s}</option>`).join('');
        }

        ruleFilterTypeEl.addEventListener('change', () => {
          populateRuleFilters();
          renderRulesTable();
        });
        ruleFilterCategoryEl.addEventListener('change', () => {
          populateRuleFilters();
          renderRulesTable();
        });
        ruleFilterSubCategoryEl.addEventListener('change', renderRulesTable);
        ruleFilterResetBtn.addEventListener('click', () => {
          ruleFilterTypeEl.value = '';
          ruleFilterCategoryEl.value = '';
          ruleFilterSubCategoryEl.value = '';
          populateRuleFilters();
          renderRulesTable();
        });

        function getRuleFilterValues() {
          return {
            type: ruleFilterTypeEl.value,
            category: ruleFilterCategoryEl.value,
            subCategory: ruleFilterSubCategoryEl.value,
            keyword: ruleSearchKeywordInput.value.trim().toLowerCase()
          };
        }

        // After loading or updating rulesDB, call populateRuleFilters() to keep dropdowns in sync.
        // ... existing code ...
    </script>
</body>
</html>
